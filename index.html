<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>3매칭 머지 프로토타입 (5x7) - 총합본</title>
<style>
  :root{
    --cell:60px; --gap:6px; --cols:5; --rows:7;
    --board-w: calc(var(--cols)*(var(--cell)) + (var(--cols)-1)*var(--gap));
    --board-h: calc(var(--rows)*(var(--cell)) + (var(--rows)-1)*var(--gap));
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:#0b0f14;color:#e8f0ff;font-family:system-ui,Segoe UI,Arial,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;gap:10px;padding:12px;
  }
  h1{font-size:16px;margin:6px 0 0;opacity:.9}
  #ui{display:flex;gap:8px;align-items:center;font-size:12px;opacity:.8}
  #board-wrap{position:relative;width:var(--board-w);height:var(--board-h)}
  #board{
    position:absolute;left:0;top:0;
    display:grid;grid-template-columns:repeat(var(--cols), var(--cell));
    grid-template-rows:repeat(var(--rows), var(--cell));
    gap:var(--gap);
  }
  .cell{
    width:var(--cell);height:var(--cell);
    background:#111723;border:1px solid #1c2433;border-radius:10px;
    display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;
  }
  .cell.blocked{
    background:#202733;
  }
  .cell.blocked::after{
    content:"✕";
    color:#8090a6;font-size:18px;opacity:.6;
  }
  .tile{
    position:absolute;left:0;top:0;width:var(--cell);height:var(--cell);
    display:flex;align-items:center;justify-content:center;
    border-radius:12px;font-weight:800;font-size:18px;letter-spacing:.5px;
    color:#0b0f14; user-select:none; pointer-events:auto;
    transform:translate3d(0,0,0) scale(1); transition:transform .18s cubic-bezier(.2, .9, .2, 1);
    box-shadow:0 6px 16px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.08);
  }
  .tile[data-v="1"]{background:#9fd3ff}
  .tile[data-v="2"]{background:#7ee7c8}
  .tile[data-v="3"]{background:#ffe08a}
  .tile[data-v="4"]{background:#ffb3b3}
  .tile[data-v="5"]{background:#d4b5ff}
  .tile[data-v="6"]{background:#ffdfdf}
  .tile.selected{outline:3px solid #66ffd1; outline-offset:-3px; z-index:10}

  /* 스폰 & 도착(매칭 실패) 공용 ‘띠용’ */
  @keyframes pop {
    0%{transform:scale(.2)}
    60%{transform:scale(1.12)}
    100%{transform:scale(1)}
  }
  .pop{animation:pop .22s cubic-bezier(.2,1.2,.2,1) forwards}

  /* 머지 시 살짝 크게 튀기는 액션 */
  @keyframes merge-bounce {
    0%{transform:scale(1)}
    35%{transform:scale(1.15)}
    100%{transform:scale(1)}
  }
  .merge-bounce{animation:merge-bounce .26s cubic-bezier(.2,1.2,.2,1) forwards}

  /* 제거되는 타일 페이드 */
  .fade-out{transition:opacity .18s ease, transform .18s ease; opacity:0; transform:scale(.6)}

  /* 경로 라인 (단일 얇은 선, 끊김 없음) */
  #path-layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
  .path-stroke{
    fill:none; stroke:#e8f0ff; stroke-width:2; stroke-linecap:round; stroke-linejoin:round;
    filter: drop-shadow(0 0 2px rgba(232,240,255,.6));
    opacity:.9; transition:opacity .4s ease;
  }
  .path-fade{opacity:0}

  /* 툴팁 */
  .hint{font-size:12px;opacity:.7;margin-top:2px}
  button{
    background:#1a2533;color:#e8f0ff;border:1px solid #2a394f;border-radius:8px;padding:8px 10px;
    cursor:pointer;font-weight:700
  }
  button:active{transform:translateY(1px)}
</style>
</head>
<body>
  <h1>3매칭 머지 (5×7) — 총합본</h1>
  <div id="ui">
    <button id="resetBtn">리셋</button>
    <span>턴: <b id="turn">0</b></span>
    <span>다음 스폰까지: <b id="spawnIn">5</b>턴</span>
  </div>
  <div id="board-wrap">
    <svg id="path-layer" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
    <div id="board"></div>
  </div>
  <div class="hint">규칙: 빈칸 경로가 있어야 이동 가능. 도착 지점의 상하좌우에 같은 숫자가 최소 1개 있어야 이동 허용. 이동 후 3+ 연결이면 즉시 머지.</div>

<script>
(() => {
  const COLS = 5, ROWS = 7;
  const NEW_TILE_VALUES = [1,1,1,2,2,3]; // 새로 나오는 값 분포
  const INITIAL_TILES = 10; // 초기 생성 수
  const BLOCKED_MIN = 2, BLOCKED_MAX = 3;
  const TURNS_PER_SPAWN = 5; // 5턴마다 새 블록 4~5개 생성

  const boardEl = document.getElementById('board');
  const pathLayer = document.getElementById('path-layer');
  const turnEl = document.getElementById('turn');
  const spawnInEl = document.getElementById('spawnIn');

  // 상태
  let grid = createEmpty();
  let blocked = new Set(); // "r,c"
  let tiles = new Map(); // id -> {id, r, c, v, el}
  let selectedId = null;
  let turn = 0, turnsUntilSpawn = TURNS_PER_SPAWN;

  // 유틸
  const key = (r,c)=> `${r},${c}`;
  const inBounds = (r,c)=> r>=0 && r<ROWS && c>=0 && c<COLS;
  const neighbors4 = (r,c)=> [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([rr,cc])=>inBounds(rr,cc));

  function createEmpty(){
    return Array.from({length:ROWS},()=> Array.from({length:COLS},()=> null));
  }

  function cellCenterPx(r,c){
    // 보드 내 좌표 px
    const styles = getComputedStyle(document.documentElement);
    const cell = parseInt(styles.getPropertyValue('--cell'));
    const gap = parseInt(styles.getPropertyValue('--gap'));
    const x = c*(cell+gap) + cell/2;
    const y = r*(cell+gap) + cell/2;
    return {x,y};
  }

  function gridToPx(r,c){
    const styles = getComputedStyle(document.documentElement);
    const cell = parseInt(styles.getPropertyValue('--cell'));
    const gap = parseInt(styles.getPropertyValue('--gap'));
    const x = c*(cell+gap);
    const y = r*(cell+gap);
    return {x,y};
  }

  function drawBoard(){
    boardEl.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        if(blocked.has(key(r,c))) cell.classList.add('blocked');
        cell.dataset.r = r; cell.dataset.c = c;
        cell.addEventListener('click', ()=> onCellClick(r,c));
        boardEl.appendChild(cell);
      }
    }
    // 타일 DOM 추가
    tiles.forEach(t => {
      boardEl.appendChild(t.el);
      placeTileElement(t);
    });
  }

  function makeTileEl(t){
    const el = document.createElement('div');
    el.className = 'tile pop';
    el.textContent = t.v;
    el.dataset.v = t.v;
    el.style.zIndex = 5;
    el.addEventListener('click', (e)=>{ e.stopPropagation(); onTileClick(t.id); });
    return el;
  }

  function placeTileElement(t){
    const {x,y} = gridToPx(t.r,t.c);
    t.el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(1)`;
  }

  function randomChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function randomEmptyCell(){
    const empties = [];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      if(!grid[r][c] && !blocked.has(key(r,c))) empties.push([r,c]);
    }
    return empties.length? randomChoice(empties) : null;
  }

  function addRandomTile(value=null, withSpawnAnim=true){
    const pos = randomEmptyCell();
    if(!pos) return false;
    const [r,c] = pos;
    const v = value ?? randomChoice(NEW_TILE_VALUES);
    const id = crypto.randomUUID();
    const tile = {id,r,c,v,el:null};
    grid[r][c] = id;
    tiles.set(id, tile);
    tile.el = makeTileEl(tile);
    if(!withSpawnAnim) tile.el.classList.remove('pop');
    tile.el.textContent = v;
    tile.el.dataset.v = v;
    boardEl.appendChild(tile.el);
    placeTileElement(tile);
    return true;
  }

  function clusterSame(r,c, v=null){
    const id = grid[r][c];
    if(!id) return [];
    const baseV = v ?? tiles.get(id).v;
    const seen = new Set();
    const q = [[r,c]];
    const res = [];
    while(q.length){
      const [rr,cc] = q.shift();
      const k = key(rr,cc);
      if(seen.has(k)) continue;
      seen.add(k);
      const tid = grid[rr][cc];
      if(!tid) continue;
      const tv = tiles.get(tid).v;
      if(tv !== baseV) continue;
      res.push([rr,cc]);
      for(const [nr,nc] of neighbors4(rr,cc)) q.push([nr,nc]);
    }
    return res;
  }

  function hasAdjSameAt(r,c,v){
    return neighbors4(r,c).some(([rr,cc])=>{
      const id = grid[rr][cc];
      return id && tiles.get(id).v===v;
    });
  }

  // BFS 경로: 시작(r0,c0) -> 도착(r1,c1)까지, 중간은 빈칸만 통과 가능
  function bfsPath(r0,c0, r1,c1){
    const q=[[r0,c0]];
    const prev = new Map();
    const sk = key(r0,c0);
    prev.set(sk, null);
    const passable = (r,c)=> (r===r0 && c===c0) || (!grid[r][c] && !blocked.has(key(r,c)));
    while(q.length){
      const [r,c]=q.shift();
      if(r===r1 && c===c1) break;
      for(const [nr,nc] of neighbors4(r,c)){
        if(!passable(nr,nc)) continue;
        const k=key(nr,nc);
        if(prev.has(k)) continue;
        prev.set(k, [r,c]);
        q.push([nr,nc]);
      }
    }
    const endK = key(r1,c1);
    if(!prev.has(endK)) return null;
    const path = [];
    let cur = [r1,c1];
    while(cur){
      path.push(cur);
      cur = prev.get(key(cur[0],cur[1]));
    }
    path.reverse();
    return path;
  }

  function deselect(){
    if(!selectedId) return;
    const t = tiles.get(selectedId);
    if(t) t.el.classList.remove('selected');
    selectedId = null;
  }

  function onTileClick(id){
    if(selectedId === id){ deselect(); return; }
    deselect();
    selectedId = id;
    const t = tiles.get(id);
    if(t) t.el.classList.add('selected');
  }

  function onCellClick(r,c){
    if(!selectedId) return;
    if(grid[r][c]) return; // 빈칸만 목적지
    if(blocked.has(key(r,c))) return;

    const t = tiles.get(selectedId);
    if(!t) return;

    // 경로 존재해야 함(빈칸만 통과)
    const path = bfsPath(t.r, t.c, r, c);
    if(!path){ pulseDenied(); return; }

    // 목적지 인접 같은 숫자 ≥1 이어야 이동 허용
    if(!hasAdjSameAt(r,c,t.v)){ pulseDenied(); return; }

    performMoveWithPath(t, path);
  }

  function pulseDenied(){
    // 간단한 거부 피드백(선택 타일 살짝 흔들기)
    if(!selectedId) return;
    const el = tiles.get(selectedId)?.el;
    if(!el) return;
    el.animate([
      {transform:el.style.transform + ' rotate(0deg)'},
      {transform:el.style.transform + ' rotate(-3deg)'},
      {transform:el.style.transform + ' rotate(3deg)'},
      {transform:el.style.transform + ' rotate(0deg)'},
    ], {duration:140, easing:'ease-out'});
  }

  function drawPathPolyline(path){
    // path: [[r,c],...]; SVG polyline으로 단일 선
    // px -> % 좌표로 변환해 viewBox=0 0 boardW boardH 대신, clientBBox 사용 없이 간단 변환
    const styles = getComputedStyle(document.documentElement);
    const cell = parseInt(styles.getPropertyValue('--cell'));
    const gap = parseInt(styles.getPropertyValue('--gap'));
    const W = COLS*(cell) + (COLS-1)*gap;
    const H = ROWS*(cell) + (ROWS-1)*gap;

    // SVG 크기를 고정 픽셀 좌표계로
    pathLayer.setAttribute('viewBox', `0 0 ${W} ${H}`);

    // 좌표들
    const pts = path.map(([r,c])=>{
      const {x,y} = cellCenterPx(r,c);
      return `${x},${y}`;
    }).join(' ');

    const pl = document.createElementNS('http://www.w3.org/2000/svg','polyline');
    pl.setAttribute('points', pts);
    pl.setAttribute('class','path-stroke');
    pathLayer.appendChild(pl);

    // 1.6s 유지 후 페이드아웃 -> 제거
    setTimeout(()=> pl.classList.add('path-fade'), 1600);
    setTimeout(()=> pl.remove(), 2100);
  }

  function performMoveWithPath(t, path){
    // 시각 경로 라인 먼저 그리기
    drawPathPolyline(path);

    // 실제 이동: 애니메이션으로 목적지까지 translate
    const [destR, destC] = path[path.length-1];

    // 논리 그리드 갱신(목적지 차지)
    grid[t.r][t.c] = null;
    grid[destR][destC] = t.id;

    // 비활성화 중복 클릭 방지
    boardEl.style.pointerEvents = 'none';

    // 타일 이동 애니메이션(연속 경로를 한 번에)
    const {x,y} = gridToPx(destR,destC);
    t.el.style.transition = 'transform .22s cubic-bezier(.2, .9, .2, 1)';
    t.el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(1)`;

    const done = () => {
      t.r = destR; t.c = destC;
      // 이동 후 매칭 검사
      const cluster = clusterSame(destR,destC);
      if(cluster.length >= 3){
        // 즉시 머지
        doMerge(destR,destC, cluster);
      }else{
        // 매칭 실패: 생성과 동일한 스케일 액션
        t.el.classList.remove('pop'); void t.el.offsetWidth; // reflow
        t.el.classList.add('pop');
      }
      // 턴 처리
      afterTurn();
      // 선택 해제
      deselect();
      boardEl.style.pointerEvents = '';
      t.el.removeEventListener('transitionend', done);
    };
    t.el.addEventListener('transitionend', done, {once:true});
  }

  function doMerge(destR,destC, cluster){
    // dest를 제외한 나머지 제거 -> dest 값 +1 -> 이펙트
    const destId = grid[destR][destC];
    const baseV = tiles.get(destId).v;

    for(const [r,c] of cluster){
      const id = grid[r][c];
      if(id === destId) continue;
      const tile = tiles.get(id);
      if(!tile) continue;
      tile.el.classList.add('fade-out');
      grid[r][c] = null;
      // DOM 제거는 약간 지연
      setTimeout(()=>{ tile.el.remove(); tiles.delete(id); }, 180);
    }
    // 도착 타일 값을 +1하고 바운스
    const destTile = tiles.get(destId);
    destTile.v = baseV + 1;
    destTile.el.dataset.v = destTile.v;
    destTile.el.textContent = destTile.v;
    destTile.el.classList.remove('merge-bounce'); void destTile.el.offsetWidth;
    destTile.el.classList.add('merge-bounce');

    // 연쇄 머지(새 값으로 다시 3+가 되는지 루프)
    setTimeout(()=>{
      let changed = true;
      while(changed){
        changed = false;
        const cl = clusterSame(destTile.r, destTile.c);
        if(cl.length >= 3){
          const v0 = destTile.v;
          for(const [r,c] of cl){
            const id = grid[r][c];
            if(id === destTile.id) continue;
            const rem = tiles.get(id);
            if(!rem) continue;
            rem.el.classList.add('fade-out');
            grid[r][c] = null;
            setTimeout(()=>{ rem.el.remove(); tiles.delete(id); }, 180);
          }
          destTile.v = v0 + 1;
          destTile.el.dataset.v = destTile.v;
          destTile.el.textContent = destTile.v;
          destTile.el.classList.remove('merge-bounce'); void destTile.el.offsetWidth;
          destTile.el.classList.add('merge-bounce');
          changed = true;
        }
      }
    }, 200);
  }

  function afterTurn(){
    turn++; turnsUntilSpawn--;
    if(turnsUntilSpawn<=0){
      // 4~5개 스폰
      const count = 4 + Math.floor(Math.random()*2);
      for(let i=0;i<count;i++) addRandomTile();
      turnsUntilSpawn = TURNS_PER_SPAWN;
      // 시작 시 3매칭 억제(최소 노력: 즉시 3+가 생기면 해당 스폰 롤백하고 다시 시도)
      squashImmediateTriples();
    }
    updateUI();
    // 이동 가능성 체크 -> 게임오버
    if(!anyMoveAvailable()){
      setTimeout(()=> alert('이동 불가! 게임 오버'), 10);
    }
  }

  function updateUI(){
    turnEl.textContent = turn;
    spawnInEl.textContent = turnsUntilSpawn;
  }

  function squashImmediateTriples(maxTries=20){
    // 생성 직후 즉시 3+ 클러스터가 생기지 않도록(초기 및 스폰 시)
    // 간단한 재롤 방식
    for(let tries=0;tries<maxTries;tries++){
      let ok = true;
      outer: for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const id = grid[r][c];
          if(!id) continue;
          const cl = clusterSame(r,c);
          if(cl.length>=3){ ok=false; break outer; }
        }
      }
      if(ok) return;
      // 하나 랜덤 선택해서 값 바꾸기
      const filled=[];
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]) filled.push([r,c]);
      if(!filled.length) return;
      const [rr,cc] = randomChoice(filled);
      const id = grid[rr][cc];
      const t = tiles.get(id);
      t.v = randomChoice(NEW_TILE_VALUES);
      t.el.dataset.v = t.v;
      t.el.textContent = t.v;
    }
  }

  function anyMoveAvailable(){
    // 어떤 타일이라도: 도착 가능한 빈칸 중, 목적지 인접 같은 숫자 ≥1 이고 경로 존재 -> 이동 가능
    for(const t of tiles.values()){
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        if(grid[r][c] || blocked.has(key(r,c))) continue;
        if(!hasAdjSameAt(r,c,t.v)) continue;
        const path = bfsPath(t.r,t.c,r,c);
        if(path) return true;
      }
    }
    return false;
  }

  function resetAll(){
    // 초기화
    grid = createEmpty();
    tiles.clear();
    blocked.clear();
    selectedId = null;
    turn = 0; turnsUntilSpawn = TURNS_PER_SPAWN;

    // 사용불가 슬롯 2~3개
    const toBlock = BLOCKED_MIN + Math.floor(Math.random()*(BLOCKED_MAX-BLOCKED_MIN+1));
    let tries=0;
    while(blocked.size < toBlock && tries<200){
      const r = Math.floor(Math.random()*ROWS), c = Math.floor(Math.random()*COLS);
      if(blocked.has(key(r,c))) { tries++; continue; }
      blocked.add(key(r,c));
    }

    drawBoard();

    // 초기 타일 생성(3연결 억제 보정 포함)
    for(let i=0;i<INITIAL_TILES;i++) addRandomTile();
    squashImmediateTriples(50);
    updateUI();
  }

  // 이벤트
  document.getElementById('resetBtn').addEventListener('click', ()=> resetAll());

  // 시작
  resetAll();
})();
</script>
</body>
</html>
