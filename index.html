<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>3매칭 머지 프로토타입 (5x7) - 총합본</title>
  <style>
    :root{
      --cell:60px; --gap:6px; --cols:5; --rows:7;
      --board-w: calc(var(--cols)*(var(--cell)) + (var(--cols)-1)*var(--gap));
      --board-h: calc(var(--rows)*(var(--cell)) + (var(--rows)-1)*var(--gap));
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;background:#0b0f14;color:#e8f0ff;font-family:system-ui,Segoe UI,Arial,sans-serif;
      display:flex;flex-direction:column;align-items:center;gap:10px;padding:14px;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    h1{font-size:16px;margin:4px 0 0}
    #topbar{display:flex;gap:8px;align-items:center}
    button{all:unset;background:#1c2735;border:1px solid #2b3a4e;padding:8px 12px;border-radius:10px;cursor:pointer}
    button:active{transform:scale(.98)}
    /* 보드 래퍼 */
    .board-wrap{
      position:relative;width:var(--board-w);height:var(--board-h);
      margin-inline:auto; /* 정렬 안정화 */
    }
    #board{
      position:absolute;inset:0;
      display:grid;grid-template-columns:repeat(var(--cols),var(--cell));
      grid-template-rows:repeat(var(--rows),var(--cell));
      gap:var(--gap);
    }
    .cell{
      width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;
      background:#1a2330;border-radius:12px;font-weight:800;font-size:20px;cursor:pointer;user-select:none;
      outline-offset:-3px; position:relative; overflow:hidden;
      transition:transform .12s ease;
    }
    .cell.empty{background:#0f141c;color:#333;cursor:default}
    .cell.blocked{background:#2a2a2a;color:#555;border:1px solid #333;cursor:default}
    .cell.sel{outline:3px solid #6ee7ff}

    /* 숫자 칩 */
    .chip{width:86%;height:86%;border-radius:14px;background:#233146;display:flex;align-items:center;justify-content:center;
      box-shadow:0 4px 10px rgba(0,0,0,.35) inset, 0 2px 6px rgba(0,0,0,.2);
      border:1px solid #33507a;font-size:22px}
    .val1 .chip{background:#20324b;border-color:#2f5484}
    .val3 .chip{background:#2a3b56;border-color:#3b699a}
    .val9 .chip{background:#28425f;border-color:#4a7fb3}
    .val27 .chip{background:#24506f;border-color:#5b98cf}
    .val81 .chip{background:#1f5d7e;border-color:#6fb1eb}

    /* 등장/도착 공용 스케일(띠용~) */
    @keyframes pop { 0%{transform:scale(.6)} 60%{transform:scale(1.18)} 100%{transform:scale(1)} }
    .pop .chip{animation:pop .28s cubic-bezier(.2,1.1,.2,1)}

    /* 병합 직후 강조 */
    @keyframes mergePop { 0%{transform:scale(1)} 40%{transform:scale(1.22)} 100%{transform:scale(1)} }
    .merge-pop .chip{animation:mergePop .24s cubic-bezier(.2,1.1,.2,1)}

    /* 이동 동선 라인 (SVG) */
    .path-line{position:absolute;inset:0;pointer-events:none}
    .path-line line{
      stroke:#bfe9ff; stroke-width:2; stroke-linecap:round; opacity:.95;
      filter: drop-shadow(0 0 4px rgba(110,231,255,.55));
      animation: fadeOut 2s ease forwards;
      shape-rendering: geometricPrecision;
    }
    @keyframes fadeOut { 0%{opacity:.95} 100%{opacity:0} }

    /* 플로팅 토큰(이동 애니) */
    .float-token{
      position:absolute; width:var(--cell); height:var(--cell);
      display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:5;
      transition: transform .32s cubic-bezier(.2,.9,.2,1);
      will-change: transform;
    }
  </style>
</head>
<body>
  <h1>5x7 3매칭 머지 (단층)</h1>
  <div id="topbar">
    <button id="resetBtn">리셋</button>
    <div id="info" style="opacity:.8;font-size:12px">이동 5턴마다 신규 블록 등장</div>
  </div>

  <div class="board-wrap" id="wrap">
    <svg class="path-line" id="pathSvg" viewBox="0 0 300 420" preserveAspectRatio="none"></svg>
    <div id="board"></div>
  </div>

  <script>
    // ====== 그리드/픽셀 메트릭스 ======
    const COLS=5, ROWS=7;
    const css = getComputedStyle(document.documentElement);
    const CELL = parseFloat(css.getPropertyValue('--cell')) || 60;
    const GAP  = parseFloat(css.getPropertyValue('--gap'))  || 6;
    const BW = COLS*CELL + (COLS-1)*GAP;
    const BH = ROWS*CELL + (ROWS-1)*GAP;

    const board = document.getElementById('board');
    const wrap  = document.getElementById('wrap');
    const pathSvg = document.getElementById('pathSvg');
    const resetBtn = document.getElementById('resetBtn');

    // SVG 좌표계를 보드 픽셀에 고정 (정렬 문제 근본 해결)
    pathSvg.setAttribute('viewBox', `0 0 ${BW} ${BH}`);

    let grid=[], sel=null, moveCount=0, gameOver=false;

    resetBtn.addEventListener('click', init);

    function init(){
      gameOver=false; moveCount=0; sel=null; grid=[]; board.innerHTML='';
      // 초기 배치
      for(let r=0;r<ROWS;r++){
        const row=[];
        for(let c=0;c<COLS;c++){
          const v = Math.random()<0.55 ? (Math.random()<0.8?1:3) : 0; // 55% 채움
          row.push(v);
          const cell = makeCell(r,c,v);
          board.appendChild(cell);
          if(v>0) playSpawnPop(cell); // 초기 생성도 '띠용~'
        }
        grid.push(row);
      }
      suppressInitialTriples();
      placeBlockers(2 + Math.floor(Math.random()*2));
      render(); // 블로커 반영
      clearPath(); // 라인 클린
    }

    function makeCell(r,c,v){
      const el=document.createElement('div');
      el.className='cell'+(v? '' : ' empty');
      el.dataset.r=r; el.dataset.c=c;
      el.addEventListener('click', ()=>onTap(r,c));
      drawChip(el,v);
      return el;
    }
    function drawChip(el,v){
      el.innerHTML='';
      if(v===-1){ el.className='cell blocked'; return; }
      if(v===0){ el.classList.add('empty'); return; }
      el.classList.remove('empty');
      const chip=document.createElement('div');
      chip.className='chip';
      el.classList.remove(...[1,3,9,27,81].map(x=>`val${x}`));
      el.classList.add(`val${v<=81?v:81}`); // 색상 등급 제한
      chip.textContent=v;
      el.appendChild(chip);
    }

    function onTap(r,c){
      if(gameOver) return;
      const val=grid[r][c];
      const cellEl=cellAt(r,c);

      // 1) 선택 시작: 숫자만
      if(!sel){
        if(val<=0) return;
        sel={r,c};
        cellEl.classList.add('sel');
        return;
      }

      // 2) 두번째 탭 처리
      const prev=sel; sel=null;
      cellAt(prev.r,prev.c).classList.remove('sel');
      // 같은 칸 취소
      if(prev.r===r && prev.c===c) return;
      // 목적지는 빈칸만
      if(grid[r][c]!==0) return;

      const fromVal = grid[prev.r][prev.c];

      // 규칙: 직선 + 경로 빈칸 + 도착 인접 동일값
      if(!(prev.r===r || prev.c===c)) return;             // 직선만
      if(!emptyPathClear(prev.r,prev.c, r,c)) return;     // 통로 비어있기
      if(!hasAdjacentSame(r,c, fromVal)) return;          // 도착칸 인접 동일값

      // 이동
      animateMoveWithPath(prev.r,prev.c, r,c, fromVal)
        .then(mergedHappened=>{
          moveCount++;
          if(moveCount>0 && moveCount%5===0){
            spawnNewBlocks(4 + Math.floor(Math.random()*2));
            renderSpawnsPop();
          }
          if(!hasAnyLegalMove()){
            gameOver=true;
            setTimeout(()=>alert('이동 불가! 게임 오버'),10);
          }
        });
    }

    function cellAt(r,c){ return board.children[r*COLS+c]; }

    function emptyPathClear(r1,c1,r2,c2){
      if(r1===r2){
        const [a,b]= c1<c2? [c1+1,c2-1]:[c2+1,c1-1];
        for(let c=a;c<=b;c++) if(grid[r1][c]!==0) return false;
        return true;
      }
      if(c1===c2){
        const [a,b]= r1<r2? [r1+1,r2-1]:[r2+1,r1-1];
        for(let r=a;r<=b;r++) if(grid[r][c1]!==0) return false;
        return true;
      }
      return false;
    }

    function hasAdjacentSame(r,c,val){
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      return dirs.some(([dr,dc])=>{
        const nr=r+dr,nc=c+dc;
        if(nr<0||nr>=ROWS||nc<0||nc>=COLS) return false;
        return grid[nr][nc]===val;
      });
    }

    // ===== (r,c) → 보드 픽셀 좌표(중앙) : DOM 측정 대신 수학적 계산 사용 =====
    function cellCenterPx(r,c){
      const x = c*(CELL+GAP) + CELL/2;
      const y = r*(CELL+GAP) + CELL/2;
      return {x,y};
    }

    // ===== 이동 애니메이션 & 동선 라인 =====
    function animateMoveWithPath(sr,sc, tr,tc, val){
      return new Promise(resolve=>{
        // ★★ 시작/끝 좌표를 먼저 "고정" (이후 DOM 변경이 좌표에 영향 X)
        const a = cellCenterPx(sr,sc);
        const b = cellCenterPx(tr,tc);

        // 1) 경로 라인
        drawPathLine(a,b);

        // 2) 플로팅 토큰
        const token = document.createElement('div');
        token.className='float-token';
        token.appendChild(cloneChip(val));
        wrap.appendChild(token);

        // 토큰 시작 위치
        token.style.transform = `translate(${a.x - CELL/2}px, ${a.y - CELL/2}px)`;

        // 3) 이제 원본칸 비우기 (좌표 고정 이후에)
        const fromCell = cellAt(sr,sc);
        grid[sr][sc]=0;
        drawChip(fromCell,0);

        // 다음 프레임에 목적지로 이동
        requestAnimationFrame(()=>{
          token.style.transform = `translate(${b.x - CELL/2}px, ${b.y - CELL/2}px)`;
        });

        // 이동 시간 320ms 후 실제 배치 + 병합
        setTimeout(()=>{
          token.remove();
          const toCell = cellAt(tr,tc);
          grid[tr][tc]=val;
          drawChip(toCell,val);

          const merged = resolveMergeAnimated(tr,tc);

          if(!merged){ // 매칭 없으면 도착 pop
            toCell.classList.add('pop');
            setTimeout(()=>toCell.classList.remove('pop'), 320);
          }

          render();
          resolve(merged);
        }, 320);
      });
    }

    function cloneChip(val){
      const shell=document.createElement('div');
      shell.className='cell';
      drawChip(shell, val);
      return shell.firstChild; // .chip
    }

    function drawPathLine(a,b){
      clearPath();
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      // SVG는 보드 픽셀 좌표계를 그대로 사용
      line.setAttribute('x1', a.x); line.setAttribute('y1', a.y);
      line.setAttribute('x2', b.x); line.setAttribute('y2', b.y);
      pathSvg.appendChild(line);
      setTimeout(clearPath, 2000);
    }
    function clearPath(){ while(pathSvg.firstChild) pathSvg.removeChild(pathSvg.firstChild); }

    // ===== 병합 로직 (애니 포함) =====
    function resolveMergeAnimated(r,c){
      let mergedOnce=false;
      let changed=true;
      while(changed){
        changed=false;
        const v=grid[r][c];
        if(v<=0) break;
        const group=flood(r,c,v);
        if(group.length>=3){
          const others=group.filter(p=> !(p.r===r&&p.c===c));
          // 가까운 2개 우선 사용
          others.sort((a,b)=> (Math.abs(a.r=r)+Math.abs(a.c=c)) - (Math.abs(b.r=r)+Math.abs(b.c=c))); // (표현 수정)
          // ↑ 위 한 줄은 오타로 오해될 수 있어 아래 실제 계산으로 대체:
          others.sort((a,b)=> (Math.abs(a.r-r)+Math.abs(a.c-c)) - (Math.abs(b.r-r)+Math.abs(b.c-c)));
          const use=others.slice(0,2);

          // 비우기
          use.forEach(p=>{ grid[p.r][p.c]=0; drawChip(cellAt(p.r,p.c),0); });

          // 중심 승급
          grid[r][c]=v*3;
          const centerEl=cellAt(r,c);
          drawChip(centerEl, v*3);
          centerEl.classList.add('merge-pop');
          setTimeout(()=>centerEl.classList.remove('merge-pop'), 260);

          mergedOnce=true;
          changed=true;
        }
      }
      return mergedOnce;
    }

    function flood(sr,sc,v){
      const seen=new Set(), out=[], Q=[[sr,sc]];
      const key=(r,c)=> r+','+c;
      while(Q.length){
        const [r,c]=Q.shift();
        if(r<0||r>=ROWS||c<0||c>=COLS) continue;
        if(grid[r][c]!==v) continue;
        const k=key(r,c);
        if(seen.has(k)) continue;
        seen.add(k); out.push({r,c});
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=> Q.push([r+dr,c+dc]));
      }
      return out;
    }

    // ===== 렌더 & 유틸 =====
    function render(){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const v=grid[r][c];
          const el=cellAt(r,c);
          if(v===-1){ el.className='cell blocked'; el.innerHTML=''; }
          else {
            el.className='cell'+(v? '' : ' empty');
            drawChip(el,v);
          }
        }
      }
    }
    function playSpawnPop(cellEl){
      cellEl.classList.add('pop');
      setTimeout(()=>cellEl.classList.remove('pop'), 320);
    }
    function renderSpawnsPop(){
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        if(grid[r][c]>0){
          const el=cellAt(r,c);
          el.classList.add('pop'); setTimeout(()=>el.classList.remove('pop'),320);
        }
      }
    }

    // === 초기 3연결 억제 ===
    function suppressInitialTriples(){
      let changed=true, guard=0;
      while(changed && guard<50){
        changed=false; guard++;
        const seen=new Set();
        for(let r=0;r<ROWS;r++){
          for(let c=0;c<COLS;c++){
            const v=grid[r][c];
            if(v<=0) continue;
            const key=(r,c)=> r+','+c;
            if(seen.has(key(r,c))) continue;
            const g=flood(r,c,v);
            g.forEach(p=> seen.add(key(p.r,p.c)));
            if(g.length>=3){
              const pick = g[Math.floor(Math.random()*g.length)];
              grid[pick.r][pick.c]=0;
              changed=true;
            }
          }
        }
      }
    }

    // === 블로커 배치 ===
    function placeBlockers(k){
      const empties = allEmpties();
      shuffle(empties);
      for(let i=0;i<k && i<empties.length;i++){
        const {r,c}=empties[i];
        grid[r][c]=-1;
      }
    }

    // === 5턴마다 스폰 ===
    function spawnNewBlocks(k){
      const empties = allEmpties();
      if(empties.length===0) return;
      shuffle(empties);
      for(let i=0;i<k && i<empties.length;i++){
        const {r,c}=empties[i];
        grid[r][c] = Math.random()<0.8? 1:3;
        drawChip(cellAt(r,c), grid[r][c]);
      }
    }

    function allEmpties(){
      const arr=[];
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]===0) arr.push({r,c});
      return arr;
    }

    function hasAnyLegalMove(){
      for(let sr=0; sr<ROWS; sr++){
        for(let sc=0; sc<COLS; sc++){
          const v=grid[sr][sc]; if(v<=0) continue;
          // 같은 행
          for(let c=0;c<COLS;c++){
            if(grid[sr][c]!==0) continue;
            if(!emptyPathClear(sr,sc, sr,c)) continue;
            if(hasAdjacentSame(sr,c, v)) return true;
          }
          // 같은 열
          for(let r=0;r<ROWS;r++){
            if(grid[r][sc]!==0) continue;
            if(!emptyPathClear(r,sc, r,sc)) continue; // (오타 가능성 → 아래 실제 검사로 대체)
          }
          for(let r=0;r<ROWS;r++){
            if(grid[r][sc]!==0) continue;
            if(!emptyPathClear(sr,sc, r,sc)) continue;
            if(hasAdjacentSame(r,sc, v)) return true;
          }
        }
      }
      return false;
    }

    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } }

    // 시작!
    init();
  </script>
</body>
</html>
