<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>3매칭</title>
<style>
 :root{
  --cols:5; --rows:7;
  --gap:1vw;  /* 화면 너비 비율 기준으로 갭 설정 */
  --bg:#0b0f14; --fg:#e8f0ff; --muted:#7f8da3;
  --tile:#18202b; --blocked:#161922;
  --accent:#46d3ff; --ok:#67ff9a; --warn:#ffcc4d; --err:#ff6b6b;
}

  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%}
  body{
    margin:0;
    background: url('images/bg.png') no-repeat center center fixed;
    background-size: cover;
    color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
  }
  header{
    width:100%; max-width:480px; padding:12px 14px;
    display:flex; 
    flex-direction:column;   /* 세로 배치 */
    align-items:center; 
    justify-content:center;
    gap:6px;
    background:linear-gradient(180deg, rgba(11,15,20,0.95), rgba(11,15,20,0.6) 70%, transparent);
    backdrop-filter: blur(6px);
  }
 #title {
  font-size:23px;
  font-weight:700;
  color:#fff;
  text-align:center;        /* 가운데 정렬 */
}
  .stat{
   font-size:12px; 
   color:var(--muted); 
   display:flex; 
   gap:12px; 
   align-items:center; 
   flex-wrap:wrap}
   justify-content:center;  /* 👈 stat도 가운데 */
  .idtag{padding:2px 6px; border:1px solid #2a3443; border-radius:8px; color:#cfe5ff; background:#121722;}
  #version{font-size:11px; color:#6f7f95;}

#boardWrap {
  width:100%;
  display:flex;
  flex-direction:column;   /* 세로로 배치 */
  align-items:center;      /* 가운데 정렬 */
  justify-content:flex-start;
  gap:5px;                 /* 보드와 버튼 사이 간격 (원하면 0으로) */
}



#board {
   width: 90vw;              /* 화면 너비 기준 */
  max-width: 480px;         /* 최대 크기 제한 */
  aspect-ratio: 5 / 7;      /* 5x7 비율 고정 */


  display:grid;
  grid-template-columns: repeat(var(--cols), 1fr);
  grid-template-rows: repeat(var(--rows), 1fr);
  gap: var(--gap);
  position:relative;
  margin: 0 auto;
}


.cell{
  aspect-ratio:1/1;    /* 셀은 항상 정사각형 */
    background: transparent;   /* << 이걸로 변경 */
  border:1px solid #1c2736;
  border-radius:14px;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:visible;
}

  .cell::after{ content:""; position:absolute; inset:0; border-radius:14px; pointer-events:none;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03); }
  .cell.blocked{
    background:var(--blocked);
    background-image: repeating-linear-gradient(135deg, #1f2533 0 8px, #141925 8px 16px);
    border-color:#20283a;
  }
  .tile{
    position:absolute; inset:0; border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    background-size:contain;
    background-repeat:no-repeat;
    background-position:center;
    user-select:none; -webkit-user-select:none;
    transition: transform .15s ease;
  }
  .tile.sel{
  border:3px solid var(--accent);
  transform: scale(1.1);
  box-shadow: 0 0 15px var(--accent), 0 0 25px rgba(70,211,255,0.7);
  z-index: 10;
}

  .tile.spawn{ animation: pop .22s ease-out; }
  .tile.bump{ animation: bump .18s ease-out; }
  .tile.merge{ animation: merge .22s ease-in-out; }
  @keyframes pop{ from{ transform: scale(0.6); opacity:0 } to{ transform: scale(1); opacity:1 } }
  @keyframes bump{ 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }
  @keyframes merge{ 0%{transform:scale(0.95)} 50%{transform:scale(1.12)} 100%{transform:scale(1)} }

  /* 컨트롤바 */
  #controlBar{
    width:100%; max-width:480px; display:flex; gap:10px; justify-content:center; align-items:center;
    padding:10px 0 16px; 
  }
  .btn{
    appearance:none; border:1px solid #2a3443; background:#121722; color:var(--fg);
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
    transition:transform .05s ease-out, background .2s;
  }
  .btn:active{ transform: scale(0.98) }

.msg {
  position:absolute;
  top:50%; left:50%;
  transform:translate(-50%,-50%);
  background:rgba(17,26,40,0.7);   /* 👈 투명도 70% 적용 */
  border:2px solid #223043;
  padding:16px 24px;
  border-radius:12px;
  font-size:15px;
  font-weight:bold;
  color:#ffcc4d;
  opacity:0;
  white-space:pre-line;            /* 👈 \n 줄바꿈 적용 */
  transition:opacity .5s ease;
  z-index:1000;
  pointer-events:none;
   white-space: pre-line;   /* \n 인식 */
  line-height: 1.8;        /* 기본 1.2~1.4 → 1.6 정도로 */
}
.msg.show{ opacity:1 }


  /* 결과/랭킹 팝업 */
  #resultPopup { position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,0.65); z-index:999; visibility:hidden; opacity:0; transition:opacity .25s; }
  #resultPopup.show{ visibility:visible; opacity:1; }
  #resultBox { background:#161c29; padding:24px; border-radius:16px; text-align:center; min-width:360px; max-width:96vw;  width: 100%;
    box-shadow:0 10px 28px rgba(0,0,0,0.6); }
  #resultBox h2{margin:0 0 8px;font-size:20px;}
  #resultBox p{margin:6px 0;font-size:14px;color:var(--muted);}
  #resultBox .btn{margin-top:12px;}
  #rankHeader{display:flex; align-items:center; justify-content:center; gap:8px; margin-top:10px;}
  #rankings{margin-top:10px; max-height:320px; overflow-y:auto; text-align:left; border:1px solid #2a3443; border-radius:10px;}
  .rank-item{display:flex; justify-content:space-between; gap:10px; padding:6px 10px; border-bottom:1px solid #222a3b; font-size:14px;}
  .rank-item:last-child{border-bottom:none}
  .rank-item .left{display:flex; align-items:center; gap:8px;}
  .crown{font-size:16px; line-height:1}
  .top1 .crown{color:gold; filter: drop-shadow(0 0 6px rgba(255,215,0,.35));}
  .top2 .crown{color:silver; filter: drop-shadow(0 0 6px rgba(192,192,192,.3));}
  .top3 .crown{color:#cd7f32; filter: drop-shadow(0 0 6px rgba(205,127,50,.3));}
  /* 게임오버 전용 문구 */
  #noMovesMsg{margin-top:8px;font-size:13px;color:var(--warn);}
</style>
</head>
<body>
<header>
  <div id="title">3개의 몬스터를 합치세요</div>   <!-- 새 타이틀 -->
  <div class="stat"> 
    <span class="idtag" id="idView">ID: -</span>
    <span>턴: <b id="turn">0</b></span>
    <span>다음 소환: <b id="nextSpawn">3</b></span>
    <span>대소환 남음: <b id="megaLeft">5</b></span>
    <span id="version">v1.3.8</span>
  </div>
</header>

<div id="boardWrap">
  <div id="board"></div>
 <div id="controlBar">
  <button class="btn" id="btnNew">새 게임</button>
  <button class="btn" id="btnResetId">아이디 초기화</button>
  <button class="btn" id="btnRankManual">랭킹 불러오기</button>
</div>
</div>



<div class="msg" id="toast"></div>

<div id="resultPopup">
  <div id="resultBox">
    <h2 id="popupTitle">게임 오버</h2>
    <p id="finalScore"></p>
    <!-- 게임오버 전용 메시지 -->
    <p id="noMovesMsg" style="display:none;">이동 가능한 소환수가 없습니다.</p>
    <div id="rankHeader"><h3 style="margin:0;font-size:16px;">랭킹 TOP 100</h3></div>
    <div id="rankings"><div style="padding:10px">랭킹을 불러오는중...</div></div>
    <div style="margin-top:12px; display:flex; gap:8px; justify-content:center;">
      <button class="btn" id="btnRestart">다시 시작</button>
      <button class="btn" id="btnBack">돌아가기</button>
     <button class="btn" id="btnViewBest">내 최고 기록 확인</button>

    </div>
  </div>
</div>
<script>
(()=>{
  /* ====== 이미지 프리로드 ====== */
function preloadImages(urls) {
  return Promise.all(urls.map(src => new Promise(res => {
    const img = new Image();
    img.onload = res;
    img.onerror = res;
    img.src = src;
  })));
}
    const IMAGE_URLS = [
    "images/block-1.png",
    "images/block-2.png",
    "images/block-3.png",
    "images/block-4.png",
    "images/block-5.png",
    "images/block-6.png",
    "images/block-7.png",
    "images/block-8.png",
    "images/block-9.png",
    "images/blocked.png",
    "images/empty.png",
    "images/bg.png"
  ];


  /* ====== 설정 ====== */
  const GAS_URL="https://script.google.com/macros/s/AKfycbwvZAdCC4KLXx4DjVwnVWaTFAih0JfOEn0-_hxg7kqeuzU5cuOLEt0qED-HNIS3_mgm/exec";
  const COLS=5, ROWS=7;
  const INIT_TILES=12;
  const BLOCK_MIN=2, BLOCK_MAX=3;
  const SPAWN_EVERY=3;
  const SPAWN_BATCH=3;
  const MEGA_INTERVAL=5;

  // 이미지 매핑 (128x128 원본 → 축소 렌더링)
  const TILE_IMAGES = {
    1: "images/block-1.png",
    3: "images/block-2.png",
    9: "images/block-3.png",
    27: "images/block-4.png",
    81: "images/block-5.png",
    243: "images/block-6.png",
    729: "images/block-7.png",
    2187: "images/block-8.png",
    6561: "images/block-9.png"
  };

  let grid=[], turn=0, untilSpawn=SPAWN_EVERY, spawnCount=0, selected=null, history=[], gameOverShown=false;
 let lastGameState = null; // 마지막 게임오버 상태 저장
 let bestScore = 0;        // 최고 점수
let bestGameState = null; // 최고 기록의 보드 상태


  const board=document.getElementById('board');
  const elTurn=document.getElementById('turn'), elNext=document.getElementById('nextSpawn'), elMega=document.getElementById('megaLeft');
  const toast=document.getElementById('toast');
 let toastTimer = null; // 👈 전역변수 추가

function info(t,k){
  toast.textContent = t;
  toast.style.color = 
    k==='err' ? 'var(--err)' : 
    (k==='warn' ? 'var(--warn)' : 'var(--fg)');

  // show 재적용
  toast.classList.remove('show');
  void toast.offsetWidth; 
  toast.classList.add('show');

  // 타이머 초기화
  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>{
    toast.classList.remove('show');
    toastTimer = null;
  }, 2000);  // 2초 유지
}
  const popup=document.getElementById('resultPopup'), finalScore=document.getElementById('finalScore'), popupTitle=document.getElementById('popupTitle');
  const idView=document.getElementById('idView');
  const rankingsEl=document.getElementById('rankings');
  const noMovesMsg=document.getElementById('noMovesMsg');

  /* ====== 아이디 ====== */
  let playerId=localStorage.getItem("mergePlayerId");
  function askPlayerId(force=false){
    if(!playerId||force){
      let input="";
      while(!input){
        input=prompt("플레이어 아이디를 입력하세요:");
        if(input===null){ input=""; }
      }
      playerId=input.trim();
      localStorage.setItem("mergePlayerId",playerId);
      info(`아이디 설정됨: ${playerId}`);
    }
    idView.textContent="ID: "+playerId;
  }

  /* ====== 유틸 ====== */
  function cloneGrid(g){return g.map(r=>r.slice());}
  function inBounds(r,c){return r>=0&&r<ROWS&&c>=0&&c<COLS;}
  function isEmpty(r,c){return grid[r][c]===0;}
  function isBlocked(r,c){return grid[r][c]===-1;}
  function isTile(r,c){return grid[r][c]>0;}
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]];}}
  function listEmpty(){const out=[];for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c]===0)out.push({r,c});return out;}
  function randomValue(){return [1,1,1,1,3,3,9][(Math.random()*7)|0];}
 
  /* ====== 셀 & 렌더링 ====== */
  function drawCell(r,c,opt={}){
    const idx=r*COLS+c, cell=board.children[idx];
    cell.classList.toggle('blocked',isBlocked(r,c));

    // 기존 타일 제거
    const prev=cell.querySelector('.tile');
    if(prev) prev.remove();

    const v=grid[r][c];
    if(v>0){
      const t=document.createElement('div');
      t.className='tile';
      t.dataset.val=v;
      if(opt.spawn) t.classList.add('spawn');

      // 블록 이미지 매핑
      if(TILE_IMAGES[v]){
        t.style.backgroundImage=`url(${TILE_IMAGES[v]})`;
      }
      t.style.backgroundSize="contain";
      t.style.backgroundRepeat="no-repeat";
      t.style.backgroundPosition="center";

      cell.appendChild(t);
    } else if(v===-1){
      // blocked cell
      const b=document.createElement('div');
      b.className='tile';
      b.style.backgroundImage="url('images/blocked.png')";
      b.style.backgroundSize="contain";
      b.style.backgroundRepeat="no-repeat";
      b.style.backgroundPosition="center";
      cell.appendChild(b);
    } else {
      // empty cell
      const e=document.createElement('div');
      e.className='tile';
      e.style.backgroundImage="url('images/empty.png')";
      e.style.backgroundSize="contain";
      e.style.backgroundRepeat="no-repeat";
      e.style.backgroundPosition="center";
  e.style.backgroundColor="transparent"; // 투명 보장
      cell.appendChild(e);
    }
  }

  function renderAll(spawn=false){
    for(let r=0;r<ROWS;r++)
      for(let c=0;c<COLS;c++)
        drawCell(r,c,{spawn:spawn&&isTile(r,c)});
    elTurn.textContent=String(turn);
    elNext.textContent=String(untilSpawn);
    elMega.textContent=String(MEGA_INTERVAL-(spawnCount%MEGA_INTERVAL||MEGA_INTERVAL));
  }

  function highlightSelection(){
    for(const cell of board.children){
      const t=cell.querySelector('.tile');
      if(t) t.classList.remove('sel');
    }
    if(selected){
      const tile=board.children[selected.r*COLS+selected.c].querySelector('.tile');
      if(tile) tile.classList.add('sel');
    }
  }

document.getElementById('btnRankManual').addEventListener('click', ()=>{
  popupTitle.textContent="랭킹";
  finalScore.textContent="";
  noMovesMsg.style.display="none"; // 랭킹일 땐 문구 숨김
  rankingsEl.innerHTML="<div style='padding:10px'>랭킹을 불러오는중...</div>";
  popup.classList.add('show');
  loadRanking();
});

// 👇 여기 추가
document.getElementById('btnViewLast').addEventListener('click', ()=>{
  if(lastGameState){
    renderMiniBoard(lastGameState);
  } else {
    alert("저장된 마지막 판이 없습니다.");
  }
});
 

  // 최고 기록 불러오기
  const savedBestScore = localStorage.getItem("mergeBestScore");
  const savedBestState = localStorage.getItem("mergeBestState");
  if(savedBestScore && savedBestState){
    bestScore = parseInt(savedBestScore, 10);
    try{ bestGameState = JSON.parse(savedBestState); }catch(e){}
  }

  preloadImages(IMAGE_URLS).then(()=>{
    console.log("✅ 모든 이미지 프리로드 완료");
    init();
  });
  function init(){
    askPlayerId();
    board.innerHTML='';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell=document.createElement('div');
        cell.className='cell';
        cell.dataset.r=r;
        cell.dataset.c=c;
        cell.addEventListener('click',onTapCell);
        board.appendChild(cell);
      }
    }
    newGame();
  }

  function makeGrid(){return Array.from({length:ROWS},()=>Array(COLS).fill(0));}

  function newGame(){
    popupTitle.textContent="게임 오버";
    grid=makeGrid();
    placeRandomBlocks(-1,BLOCK_MIN+((Math.random()*(BLOCK_MAX-BLOCK_MIN+1))|0));
    placeRandomTilesAvoidingTriples(INIT_TILES,400);
    renderAll(true);
    requestAnimationFrame(()=>{resolveAutoMerges();saveSnapshot();});
    turn=0;untilSpawn=SPAWN_EVERY;spawnCount=0;selected=null;gameOverShown=false;
    elTurn.textContent='0';elNext.textContent=String(SPAWN_EVERY);
    popup.classList.remove('show');
    checkGameOverSoon();
  }
  /* ====== 소환 ====== */
  function placeRandomBlocks(v,count){
    const E=listEmpty();shuffle(E);
    for(let i=0;i<count&&i<E.length;i++) grid[E[i].r][E[i].c]=v;
  }
  function placeRandomTilesAvoidingTriples(count,maxTry=200){
    let placed=0,tries=0;
    while(placed<count&&tries<maxTry){
      const E=listEmpty();if(!E.length)break;
      const p=E[(Math.random()*E.length)|0],v=randomValue();
      grid[p.r][p.c]=v;
      if(findAnyGroupGE3()){grid[p.r][p.c]=0;}else{placed++;}
      tries++;
    }
    if(placed<count)placeRandomTiles(count-placed);
  }
  function placeRandomTiles(count){
    const E=listEmpty();shuffle(E);
    for(let i=0;i<count&&i<E.length;i++) grid[E[i].r][E[i].c]=randomValue();
  }
  function spawnBatch(){
    spawnCount++;
    if(spawnCount%MEGA_INTERVAL===0){
      info("🌟 대소환! 블록 2배 소환!");
      for(let i=0;i<SPAWN_BATCH*2;i++) spawnOne();
    } else {
      for(let i=0;i<SPAWN_BATCH;i++) spawnOne();
    }
    elMega.textContent=String(MEGA_INTERVAL-(spawnCount%MEGA_INTERVAL||MEGA_INTERVAL));
  }
  function spawnOne(){
    const E=listEmpty();if(!E.length)return false;
    const p=E[(Math.random()*E.length)|0];
    grid[p.r][p.c]=randomValue();
    drawCell(p.r,p.c,{spawn:true});
    resolveAutoMerges();
    return true;
  }

  /* ====== 입력/이동 ====== */
  function onTapCell(){
  const r = +this.dataset.r, c = +this.dataset.c;
  if(isTile(r,c)){
    selected = {r,c};
    highlightSelection();
    return;
  }

  if(isEmpty(r,c) && selected){
    const from = {...selected}, to = {r,c}, val = grid[from.r][from.c];
    const reasons = [];

    // 1. 경로 확인
    const path = findPathViaEmpties(from, to);
    if(!path) reasons.push("경로가 막혀 이동할 수 없습니다.");

    // 2. 옆에 같은 숫자 필요
    if(!destAdjacentSame(to, val)) reasons.push("옆에 같은 숫자가 있어야 합니다.");

    // 3. 그룹 크기 확인
    const gsize = groupSizeIfMoved(from, to, val);
    if(gsize < 2) reasons.push("이동해도 그룹이 형성되지 않습니다.");

    // 4. 두 개 붙음 예외
    const currentGroup = floodSame(from.r, from.c, val);
    if(currentGroup.length === 2 && gsize < 3) {
      reasons.push("3매칭 목적이 아니면 두개를 떼어 놓을 수 없습니다.");
    }

    // ❌ 이동 불가 처리
if(reasons.length > 0){
  console.log("info 실행:", reasons);  // 👉 콘솔에 찍히는지 확인
  info(reasons.join("\n"), "err");     // 한 줄씩 나열
  return;
}


    // ✅ 이동 가능
    moveTile(from, to);
    if(gsize >= 3) resolveAutoMerges(to);
    turn++;
    untilSpawn--;
    if(untilSpawn===0){ spawnBatch(); untilSpawn=SPAWN_EVERY; }
    saveSnapshot();
    elTurn.textContent = String(turn);
    elNext.textContent = String(untilSpawn);
    selected = null;
    highlightSelection();
    checkGameOverSoon();
  }
}


  function moveTile(from,to){
    const v=grid[from.r][from.c];
    grid[from.r][from.c]=0;grid[to.r][to.c]=v;
    drawCell(from.r,from.c);drawCell(to.r,to.c);
    const tCell=board.children[to.r*COLS+to.c].querySelector('.tile');
    if(tCell){tCell.classList.add('bump');setTimeout(()=>tCell.classList.remove('bump'),200);}
  }

  /* ====== 경로/그룹 ====== */
  function findPathViaEmpties(from,to){
    const q=[from],prev=Array.from({length:ROWS},()=>Array(COLS).fill(null)),vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
    vis[from.r][from.c]=true;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const cur=q.shift();
      for(const [dr,dc] of dirs){
        const nr=cur.r+dr,nc=cur.c+dc;
        if(!inBounds(nr,nc)||vis[nr][nc]) continue;
        if(nr===to.r&&nc===to.c){if(!isEmpty(nr,nc)) continue;}
        else if(isBlocked(nr,nc)||isTile(nr,nc)) continue;
        vis[nr][nc]=true;prev[nr][nc]=cur;
        if(nr===to.r&&nc===to.c){
          const path=[];let x={r:nr,c:nc};
          while(x){path.push(x);x=prev[x.r][x.c];}
          path.reverse();return path;
        }
        q.push({r:nr,c:nc});
      }
    }
    return null;
  }
function destAdjacentSame(to,val){
  return [[1,0],[-1,0],[0,1],[0,-1]]
    .some(([dr,dc]) => inBounds(to.r+dr,to.c+dc) && grid[to.r+dr][to.c+dc]===val);
}
  function floodSame(sr,sc,val,g=grid){
    const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false)),q=[{r:sr,c:sc}],out=[];
    vis[sr][sc]=true;
    while(q.length){
      const {r,c}=q.shift();
      out.push({r,c});
      for(const [dr,dc] of [[1,0],[0,1],[-1,0],[0,-1]]){
        const nr=r+dr,nc=c+dc;
        if(inBounds(nr,nc)&&!vis[nr][nc]&&g[nr][nc]===val){
          vis[nr][nc]=true;q.push({r:nr,c:nc});
        }
      }
    }
    return out;
  }
  function groupSizeIfMoved(from,to,val){
    const tmp=cloneGrid(grid);
    tmp[from.r][from.c]=0;tmp[to.r][to.c]=val;
    return floodSame(to.r,to.c,val,tmp).length;
  }

  /* ====== 머지 ====== */
  function findAnyGroupGE3(){
    const seen=Array.from({length:ROWS},()=>Array(COLS).fill(false));
    for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
      const v=grid[r][c];
      if(v<=0||seen[r][c]) continue;
      const comp=floodSame(r,c,v);
      for(const p of comp) seen[p.r][p.c]=true;
      if(comp.length>=3) return {val:v,group:comp};
    }
    return null;
  }
  function resolveAutoMerges(forcePivot=null){
    let merged=false;
    while(true){
      const f=findAnyGroupGE3();
      if(!f) break;
      const {val,group}=f;
      const pivot=forcePivot||group[0];
      const absorb=group.filter(p=>(p.r!==pivot.r||p.c!==pivot.c)).slice(0,2);
      for(const p of absorb){grid[p.r][p.c]=0;drawCell(p.r,p.c);}
      grid[pivot.r][pivot.c]=val*3;
      const tCell=board.children[pivot.r*COLS+pivot.c].querySelector('.tile');
      if(tCell){tCell.classList.add('merge');setTimeout(()=>tCell.classList.remove('merge'),240);}
      drawCell(pivot.r,pivot.c);merged=true;forcePivot=null;
    }
    if(merged) saveSnapshot();
  }

  /* ====== 게임오버 ====== */
  function legalMoveExistsForTile(r,c){
    const v=grid[r][c];const currentGroup=floodSame(r,c,v);
    for(let rr=0;rr<ROWS;rr++)for(let cc=0;cc<COLS;cc++){
      if(!isEmpty(rr,cc)) continue;
      const to={r:rr,c:cc};const path=findPathViaEmpties({r,c},to);if(!path) continue;
      if(!destAdjacentSame(to,v)) continue;
      const gsize=groupSizeIfMoved({r,c},to,v);if(gsize<2) continue;
      if(currentGroup.length===2&&gsize<3) continue;
      return true;
    }
    return false;
  }
  function hasAnyMoves(){
    for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
      if(grid[r][c]>0&&legalMoveExistsForTile(r,c)) return true;
    }
    return false;
  }
  function checkGameOverSoon(){
    setTimeout(()=>{
      if(!gameOverShown&&!hasAnyMoves()){
        gameOverShown=true;
        const total=grid.flat().filter(v=>v>0).reduce((a,b)=>a+b,0);
        showResult(total);
      }
    },30);
  }

  /* ====== 히스토리 ====== */
  function saveSnapshot(){history.push({grid:cloneGrid(grid),turn,untilSpawn});if(history.length>50)history.shift();}

  /* ====== 결과/랭킹 ====== */
  async function showResult(total){
  popupTitle.textContent = "게임 오버";
  finalScore.textContent = `${playerId}의 최종 점수: ${total}`;
  noMovesMsg.style.display = "block";
   // 마지막 상태 저장
lastGameState = cloneGrid(grid);
   // 최고 기록 갱신
if(total > bestScore){
  bestScore = total;
  bestGameState = cloneGrid(grid);
  localStorage.setItem("mergeBestScore", bestScore);
  localStorage.setItem("mergeBestState", JSON.stringify(bestGameState));
}



  // ✅ 팝업 먼저 표시
  rankingsEl.innerHTML = "<div style='padding:10px'>랭킹을 불러오는중...</div>";
  popup.classList.add('show');

  // ✅ 점수 전송은 비동기
  try {
   fetch(`${GAS_URL}?action=submit&id=${encodeURIComponent(playerId)}&score=${encodeURIComponent(total)}&state=${encodeURIComponent(JSON.stringify(grid))}`, {mode:'no-cors'});

  } catch(e) {}

  // ✅ 랭킹 로딩도 비동기로
  loadRanking();
}


  async function loadRanking(){
    try{
      const res=await fetch(`${GAS_URL}?action=get`,{cache:'no-cache'});
      let data=[];try{data=await res.json();}catch(e){}
      renderRanking(Array.isArray(data)?data.slice(0,100):[]);
    }catch(e){renderRanking([]);}
  }
function renderRanking(rows){
  rankingsEl.innerHTML="";
  if(!rows||rows.length===0){
    const empty=document.createElement('div');
    empty.style.padding='10px';
    empty.textContent='랭킹 데이터를 불러오지 못했습니다.';
    rankingsEl.appendChild(empty);
    return;
  }
  rows.forEach((row,i)=>{
    const item=document.createElement('div');
    item.className='rank-item'+(i===0?' top1':i===1?' top2':i===2?' top3':'');

    const left=document.createElement('div');
    left.className='left';

    const crown=document.createElement('span');
    crown.className='crown';
    crown.textContent=(i<3?'👑':'');
    left.appendChild(crown);

    const name=document.createElement('span');
    name.textContent=`${i+1}. ${row.id??row.name??'unknown'}`;
    left.appendChild(name);

    const score=document.createElement('span');
    score.textContent=`${row.score??row.point??0}`;

    item.appendChild(left);
    item.appendChild(score);

    // 👇 1~3위는 항상 돌아보기 버튼 표시
    if(i < 3){
      const btn=document.createElement('button');
      btn.textContent="보기";
      btn.className="btn";
      btn.style.padding="2px 6px";
      btn.style.fontSize="12px";
      btn.addEventListener('click',()=>{
        if(row.state){
          try{
            const state=JSON.parse(row.state);
            renderMiniPopup(state, row.id||"unknown", row.score||0);
          }catch(e){
            alert("저장된 보드 데이터를 불러올 수 없습니다.");
          }
        }else{
          alert("저장된 전적이 없습니다.");
        }
      });
      item.appendChild(btn);
    }

    rankingsEl.appendChild(item);
  });
}

// 👇 미니 팝업 함수
function renderMiniPopup(state, id, score){
  let mini=document.getElementById('miniPopup');
  if(!mini){
    mini=document.createElement('div');
    mini.id='miniPopup';
    mini.style.position='fixed';
    mini.style.inset='0';
    mini.style.background='rgba(0,0,0,0.6)';
    mini.style.display='flex';
    mini.style.alignItems='center';
    mini.style.justifyContent='center';
    mini.style.zIndex='2000';
    document.body.appendChild(mini);
  }
  mini.innerHTML='';

  const box=document.createElement('div');
  box.style.background='#161c29';
  box.style.padding='16px';
  box.style.borderRadius='12px';
  box.style.textAlign='center';
  box.style.boxShadow='0 6px 20px rgba(0,0,0,0.6)';

  const title=document.createElement('h3');
  title.textContent=`${id} 최종 보드 (점수 ${score})`;
  box.appendChild(title);

  const wrap=document.createElement('div');
  wrap.style.display='grid';
  wrap.style.gridTemplateColumns=`repeat(${COLS}, 24px)`;
  wrap.style.gridTemplateRows=`repeat(${ROWS}, 24px)`;
  wrap.style.gap='2px';
  wrap.style.marginTop='8px';

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell=document.createElement('div');
      cell.style.width='24px';
      cell.style.height='24px';
      cell.style.border='1px solid #222';
      cell.style.background='#111';
      const v=state[r][c];
      if(v > 0){
        const t=document.createElement('div');
        t.style.width='100%';
        t.style.height='100%';
        t.style.backgroundImage=`url(${TILE_IMAGES[v]||""})`;
        t.style.backgroundSize='cover';
        cell.appendChild(t);
      }else if(v === -1){
        const b=document.createElement('div');
        b.style.width='100%';
        b.style.height='100%';
        b.style.backgroundImage="url('images/blocked.png')";
        b.style.backgroundSize='cover';
        cell.appendChild(b);
      }
      wrap.appendChild(cell);
    }
  }
  box.appendChild(wrap);

  const close=document.createElement('button');
  close.textContent='닫기';
  close.className='btn';
  close.style.marginTop='10px';
  close.onclick=()=>mini.remove();
  box.appendChild(close);

  mini.appendChild(box);
}

// 안내문이 떠 있는 상태에서 두 번째 클릭 시 닫힘
document.addEventListener('click', (e) => {
  if (!toast.classList.contains('show')) return;
  if (e.target.closest('#toast')) return;
  if (toastTimer) clearTimeout(toastTimer);

  setTimeout(() => {
    toast.classList.remove('show');
    toastTimer = null;
  }, 50);
}, true);

})();
</script>
</body>
</html>


