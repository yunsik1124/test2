<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>5x7 머지 게임</title>
  <style>
    :root{
      --cell: 64px; /* 타일 한 변 */
      --gap: 8px;   /* 셀 사이 간격 */
      --cols: 5;
      --rows: 7;
      --board-w: calc(var(--cols)*var(--cell) + (var(--cols)-1)*var(--gap));
      --board-h: calc(var(--rows)*var(--cell) + (var(--rows)-1)*var(--gap));
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:#0b0f14; color:#e8f0ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display:flex; flex-direction:column; align-items:center; gap:12px;
    }
    header{ width: min(96vw, var(--board-w)); display:flex; justify-content:space-between; align-items:center; padding:10px 0; }
    h1{font-size:16px; font-weight:600; margin:0; color:#b8c9ff}
    .btn{appearance:none; border:none; background:#1a2433; color:#dfe7ff; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; box-shadow:0 2px 0 #0c121b inset, 0 0 0 1px #2a384f inset;}
    .btn:active{transform:translateY(1px)}
    .hud{display:flex; gap:10px; align-items:center; font-weight:600; color:#9cc0ff}

    /* 보드 그리드 바탕 */
    .board-wrap{position:relative; width:var(--board-w); height:var(--board-h);}    
    .grid{ position:absolute; inset:0; display:grid; grid-template-columns:repeat(var(--cols), var(--cell)); grid-template-rows:repeat(var(--rows), var(--cell)); gap:var(--gap); }
    .cell{ background:#0f1623; border-radius:14px; outline:1px solid #0f223a; }

    /* 타일 레이어 - 절대 좌표 배치 */
    .tiles{ position:absolute; inset:0; }
    .tile{ position:absolute; width:var(--cell); height:var(--cell); 
      transform: translate(var(--tx, 0px), var(--ty, 0px)) scale(var(--scale,1));
      transition: transform 220ms cubic-bezier(.2,.9,.2,1);
      display:flex; align-items:center; justify-content:center; border-radius:16px; font-weight:800; font-size:22px;
      color:#0b0f14; text-shadow: 0 1px 0 rgba(255,255,255,.15);
      box-shadow: 0 4px 14px rgba(0,0,0,.35), inset 0 -3px 0 rgba(0,0,0,.25);
      user-select:none; cursor:pointer;
    }
    .tile[data-v="1"]{ background:#e3f2ff; }
    .tile[data-v="2"]{ background:#cfe8ff; }
    .tile[data-v="3"]{ background:#b9dcff; }
    .tile[data-v="6"]{ background:#9fd0ff; }
    .tile[data-v="9"]{ background:#86c2ff; }
    .tile[data-v="18"]{ background:#6fb4ff; }
    .tile[data-v="27"]{ background:#57a6ff; color:#07121e; }
    .tile[data-v="54"]{ background:#3b97ff; color:#07121e; }
    .tile[data-v="81"]{ background:#248bff; color:#07121e; }

    .tile.selected{ outline:3px solid #fff; outline-offset:-3px; }

    /* 생성 pop */
    @keyframes popIn{ 0%{ transform:scale(.6); opacity:.0 } 60%{ transform:scale(1.08); opacity:1 } 100%{ transform:scale(1)} }
    .pop{ animation: popIn 220ms cubic-bezier(.2,.9,.2,1); }

    /* 병합 bump */
    @keyframes bump{ 0%{ transform:scale(1) } 40%{ transform:scale(1.15) } 100%{ transform:scale(1)} }
    .bump{ animation: bump 240ms cubic-bezier(.2,.9,.2,1); }

    /* 이동 라인 (SVG) 및 플로팅 토큰 */
    .fx-layer{ position:absolute; inset:0; pointer-events:none; }
    svg#line-layer{ position:absolute; inset:0; overflow:visible }
    .move-line{ stroke:#ffffff; stroke-width:2; stroke-linecap:round; stroke-opacity:1; animation: fade 2s linear forwards }
    @keyframes fade{ to{ stroke-opacity:0 } }

    .float{ position:absolute; padding:6px 10px; border-radius:16px; background:#ffffff; color:#0b0f14; font-weight:800; font-size:14px; filter:drop-shadow(0 4px 8px rgba(0,0,0,.35));
      opacity:1; transform:translate(-50%,-50%);
      animation: floatUp 2s ease-out forwards; }
    @keyframes floatUp{ 
      0%{ transform:translate(-50%,-50%) translateY(0); opacity:1 }
      100%{ transform:translate(-50%,-50%) translateY(-40px); opacity:0 }
    }

    /* 게임오버 오버레이 */
    .overlay{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(7,12,20,.72); backdrop-filter: blur(2px); border-radius:16px; }
    .overlay.show{ display:flex }
    .overlay .panel{ background:#0f1623; padding:18px 22px; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.45); border:1px solid #20314b; text-align:center }
    .overlay h2{ margin:0 0 4px; font-size:20px }
    .overlay p{ margin:0 0 12px; color:#a8b6d8 }

    /* 안내 텍스트 */
    .hint{ color:#86a0c9; font-size:12px; opacity:.9 }
  </style>
</head>
<body>
  <header>
    <h1>5x7 머지 게임</h1>
    <div class="hud">
      <span>턴: <span id="turn">0</span></span>
      <button id="reset" class="btn">리셋</button>
    </div>
  </header>

  <div class="board-wrap" id="boardWrap">
    <div class="grid" id="grid"></div>
    <div class="tiles" id="tiles"></div>
    <div class="fx-layer">
      <svg id="line-layer"></svg>
    </div>
    <div class="overlay" id="overlay">
      <div class="panel">
        <h2>게임 오버</h2>
        <p>더 이상 이동할 곳이 없어요.</p>
        <button class="btn" id="retry">다시 시작</button>
      </div>
    </div>
  </div>
  <div class="hint">규칙: 같은 숫자 옆으로만 이동 (목적지는 비어있고, 직선 경로 중간은 모두 빈칸이어야 함). 3개 이상 붙으면 합쳐져 숫자가 3배!</div>

<script>
(() => {
  const COLS = 5, ROWS = 7;
  const CELL = 64, GAP = 8;
  const boardWrap = document.getElementById('boardWrap');
  const gridEl = document.getElementById('grid');
  const tilesEl = document.getElementById('tiles');
  const lineLayer = document.getElementById('line-layer');
  const overlay = document.getElementById('overlay');
  const turnEl = document.getElementById('turn');

  // 셀 배경 생성
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r; cell.dataset.c = c;
      gridEl.appendChild(cell);
    }
  }

  // 상태
  let grid = [...Array(ROWS)].map(()=>Array(COLS).fill(null));
  let idSeq = 1;
  let selected = null; // {id, r, c, value}
  let moveCount = 0; // 매 5턴마다 스폰
  let locked = false; // 애니 중 입력 잠금

  function rcToPx(r,c){
    const x = c*(CELL+GAP);
    const y = r*(CELL+GAP);
    return {x,y};
  }

  function makeTileEl(tile){
    const el = document.createElement('div');
    el.className = 'tile pop';
    el.dataset.id = tile.id;
    el.dataset.v = tile.value;
    el.textContent = tile.value;
    positionTileEl(el, tile.r, tile.c);
    el.addEventListener('click', (e)=>{
      e.stopPropagation();
      onTileClick(tile);
    });
    return el;
  }

  function positionTileEl(el, r, c, scale=1){
    const {x,y} = rcToPx(r,c);
    el.style.setProperty('--tx', x+'px');
    el.style.setProperty('--ty', y+'px');
    el.style.setProperty('--scale', scale);
  }

  function placeNewTile(r, c, value){
    const tile = { id: idSeq++, r, c, value };
    grid[r][c] = tile;
    const el = makeTileEl(tile);
    tilesEl.appendChild(el);
    return tile;
  }

  function removeTile(tile){
    grid[tile.r][tile.c] = null;
    const el = tilesEl.querySelector(`.tile[data-id="${tile.id}"]`);
    if(el) el.remove();
  }

  function setValue(tile, newVal, bump){
    tile.value = newVal;
    const el = tilesEl.querySelector(`.tile[data-id="${tile.id}"]`);
    if(el){
      el.dataset.v = newVal;
      el.textContent = newVal;
      if(bump){
        el.classList.remove('bump'); void el.offsetWidth; el.classList.add('bump');
      }
    }
  }

  function clearSelection(){
    tilesEl.querySelectorAll('.tile.selected').forEach(n=>n.classList.remove('selected'));
    selected = null;
  }

  // 초기 스폰
  function randomStart(){
    const empties = emptyCells();
    shuffle(empties);
    const startCount = 8; // 넉넉한 시작 공간
    for(let i=0;i<Math.min(startCount, empties.length); i++){
      const [r,c] = empties[i];
      placeNewTile(r,c, randStartValue());
    }
  }

  function randStartValue(){
    // 1,2,3 중 하나 (초기엔 작은 수 위주)
    return [1,1,2,2,3][Math.floor(Math.random()*5)];
  }
  function randSpawnValue(){
    // 스폰 값 - 게임 진행 중에도 1~3 위주
    return [1,1,1,2,2,3][Math.floor(Math.random()*6)];
  }

  function emptyCells(){
    const arr=[]; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) if(!grid[r][c]) arr.push([r,c]);
    return arr;
  }

  function onTileClick(tile){
    if(locked) return;
    // 선택 토글
    const el = tilesEl.querySelector(`.tile[data-id="${tile.id}"]`);
    if(selected && selected.id === tile.id){
      clearSelection(); return;
    }
    clearSelection();
    selected = tile;
    el.classList.add('selected');
  }

  // 빈 셀 클릭으로 이동 시도
  gridEl.addEventListener('click', (e)=>{
    if(locked) return;
    if(!selected) return;
    const cell = e.target.closest('.cell');
    if(!cell) return;
    const tr = parseInt(cell.dataset.r,10), tc = parseInt(cell.dataset.c,10);
    if(grid[tr][tc]) return; // 목적지는 빈칸이어야 함

    tryMove(selected, tr, tc);
  });

  function tryMove(tile, tr, tc){
    // 1) 직선 경로인지
    if(!(tile.r === tr || tile.c === tc)) return buzz();
    // 2) 경로 중간이 전부 빈칸인지
    if(!pathIsClear(tile.r, tile.c, tr, tc)) return buzz();
    // 3) 목적지가 같은 숫자와 인접한가(4방)
    if(!adjacentHasSameValue(tr, tc, tile.value)) return buzz();

    // 이동 실행
    doMove(tile, tr, tc);
  }

  function buzz(){
    // 가벼운 거부 피드백 (선택 해제 X)
    const el = selected && tilesEl.querySelector(`.tile[data-id="${selected.id}"]`);
    if(el){ el.style.transition = 'transform 90ms';
      const origTx = el.style.getPropertyValue('--tx');
      const origTy = el.style.getPropertyValue('--ty');
      el.style.setProperty('--tx', `calc(${origTx} + 4px)`);
      setTimeout(()=>{ el.style.setProperty('--tx', origTx); el.style.transition = ''; }, 100);
    }
  }

  function pathIsClear(r1, c1, r2, c2){
    if(r1===r2){
      const [from,to] = c1<c2 ? [c1,c2] : [c2,c1];
      for(let c=from+1; c<to; c++){ if(grid[r1][c]) return false; }
      return true;
    }
    if(c1===c2){
      const [from,to] = r1<r2 ? [r1,r2] : [r2,r1];
      for(let r=from+1; r<to; r++){ if(grid[r][c1]) return false; }
      return true;
    }
    return false;
  }

  function adjacentHasSameValue(r,c,val){
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
      const t = grid[nr][nc];
      if(t && t.value===val) return true;
    }
    return false;
  }

  function doMove(tile, tr, tc){
    locked = true;
    const from = {r: tile.r, c: tile.c};

    const el = tilesEl.querySelector(`.tile[data-id="${tile.id}"]`);
    const {x: sx, y: sy} = rcToPx(tile.r, tile.c);
    const {x: dx, y: dy} = rcToPx(tr, tc);

    // 라인 FX
    drawLineFx(sx+CELL/2, sy+CELL/2, dx+CELL/2, dy+CELL/2);

    // 실제 이동 (DOM 애니 이용)
    grid[tile.r][tile.c] = null;
    tile.r = tr; tile.c = tc;
    grid[tr][tc] = tile;

    // 이동 애니메이션
    requestAnimationFrame(()=>{
      positionTileEl(el, tr, tc);
    });

    // 도착 토큰
    setTimeout(()=>{
      spawnFloat(dx+CELL/2, dy+CELL/2, tile.value);
    }, 40);

    // 이동 종료 후 병합 판정
    setTimeout(()=>{
      const merged = tryMergeAt(tr, tc);
      moveCount++;
      turnEl.textContent = moveCount;
      clearSelection();

      // 스폰 타이밍 (매 5턴)
      if(moveCount>0 && moveCount % 5 === 0){
        spawnNewBlocks();
      }

      setTimeout(()=>{
        locked = false;
        if(checkGameOver()) showGameOver();
      }, merged? 80 : 0);
    }, 240);
  }

  function drawLineFx(x1,y1,x2,y2){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
    line.classList.add('move-line');
    lineLayer.appendChild(line);
    setTimeout(()=> line.remove(), 2000);
  }

  function spawnFloat(cx, cy, val){
    const f = document.createElement('div');
    f.className = 'float';
    f.textContent = val;
    f.style.left = cx+'px';
    f.style.top = cy+'px';
    boardWrap.appendChild(f);
    setTimeout(()=> f.remove(), 2000);
  }

  function tryMergeAt(r, c){
    const tile = grid[r][c]; if(!tile) return false;
    const group = floodSame(r,c,tile.value);
    if(group.length >= 3){
      // 병합: 그룹 모두 제거하고, 목적지(현재 위치)에 3배로 세팅
      // 목적지는 그룹 내 현재 타일(방금 이동한 타일)로 유지
      for(const {r:gr, c:gc} of group){
        if(gr===r && gc===c) continue; // 자신 제외
        const t = grid[gr][gc];
        if(t) removeTile(t);
      }
      setValue(tile, tile.value*3, true);
      // 그룹 자리를 비우기
      for(const {r:gr, c:gc} of group){ if(!(gr===r&&gc===c)) grid[gr][gc]=null; }
      return true;
    }
    return false;
  }

  function floodSame(sr, sc, val){
    const vis = new Set();
    const q=[[sr,sc]]; vis.add(sr+','+sc);
    const out=[{r:sr,c:sc}];
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const [r,c] = q.shift();
      for(const [dr,dc] of dirs){
        const nr=r+dr, nc=c+dc; const key=nr+','+nc;
        if(nr<0||nr>=ROWS||nc<0||nc>=COLS||vis.has(key)) continue;
        const t = grid[nr][nc];
        if(t && t.value===val){ vis.add(key); q.push([nr,nc]); out.push({r:nr,c:nc}); }
      }
    }
    return out;
  }

  function spawnNewBlocks(){
    const empties = emptyCells();
    if(empties.length===0) return;
    shuffle(empties);
    const count = Math.min(empties.length, 4 + Math.floor(Math.random()*2)); // 4~5개
    for(let i=0;i<count;i++){
      const [r,c] = empties[i];
      placeNewTile(r,c, randSpawnValue());
    }
  }

  function checkGameOver(){
    // 빈칸이 전혀 없고 이동도 불가 OR 빈칸이 있어도 어떤 이동도 불가
    return !hasAnyLegalMove();
  }

  function hasAnyLegalMove(){
    // 모든 타일에 대해: 같은 값 인접을 만족하는 목적지로의 직선/빈칸 경로가 있는가?
    // 목적지는 비어있고, 같은 값 타일과 인접해야 함
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const t = grid[r][c]; if(!t) continue;
        // 같은 행의 빈칸들
        for(let cc=0; cc<COLS; cc++){
          if(cc===c) continue; if(grid[r][cc]) continue;
          if(!pathIsClear(r,c,r,cc)) continue;
          if(adjacentHasSameValue(r,cc,t.value)) return true;
        }
        // 같은 열의 빈칸들
        for(let rr=0; rr<ROWS; rr++){
          if(rr===r) continue; if(grid[rr][c]) continue;
          if(!pathIsClear(r,c,rr,c)) continue;
          if(adjacentHasSameValue(rr,c,t.value)) return true;
        }
      }
    }
    return false;
  }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } }

  function reset(){
    // 정리
    grid = [...Array(ROWS)].map(()=>Array(COLS).fill(null));
    selected = null; idSeq=1; moveCount=0; turnEl.textContent='0'; locked=false;
    tilesEl.innerHTML = '';
    lineLayer.innerHTML = '';
    overlay.classList.remove('show');
    randomStart();
  }

  function showGameOver(){
    overlay.classList.add('show');
  }

  // 버튼
  document.getElementById('reset').addEventListener('click', reset);
  document.getElementById('retry').addEventListener('click', reset);

  // 시작
  reset();
})();
</script>
</body>
</html>
