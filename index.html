<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>5x7 머지 퍼즐</title>
<style>
  :root{
    --cols:5; --rows:7;
    --cell:72px; /* 모바일 세로형 */
    --gap:8px;
    --board-w: calc(var(--cols)*var(--cell) + (var(--cols)-1)*var(--gap));
    --board-h: calc(var(--rows)*var(--cell) + (var(--rows)-1)*var(--gap));
    --bg:#0b0f14; --fg:#e8f0ff; --muted:#7f8da3;
    --tile:#18202b; --blocked:#161922;
    --accent:#46d3ff; --ok:#67ff9a; --warn:#ffcc4d; --err:#ff6b6b;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
  }
  header{
    width:100%; max-width:480px; padding:12px 14px;
    position:sticky; top:0; z-index:2;
    display:flex; gap:10px; align-items:center; justify-content:space-between;
    background:linear-gradient(180deg, rgba(11,15,20,0.95), rgba(11,15,20,0.6) 70%, transparent);
    backdrop-filter: blur(6px);
  }
  .stat{font-size:12px; color:var(--muted); display:flex; gap:12px; align-items:center}
  .idtag{padding:2px 6px; border:1px solid #2a3443; border-radius:8px; color:#cfe5ff; background:#121722;}
  #version{font-size:11px; color:#6f7f95;}
  .btn{
    appearance:none; border:1px solid #2a3443; background:#121722; color:var(--fg);
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
    transition:transform .05s ease-out, background .2s;
  }
  .btn:active{ transform: scale(0.98) }
  .row{display:flex; gap:8px; align-items:center}

  #boardWrap{width:100%; display:flex; align-items:center; justify-content:center; padding:14px 0 28px; position:relative;}
  #board{
    width:var(--board-w); height:var(--board-h);
    display:grid; grid-template-columns:repeat(var(--cols), var(--cell));
    grid-template-rows:repeat(var(--rows), var(--cell));
    gap:var(--gap); touch-action: manipulation; position:relative;
  }
  .cell{
    width:var(--cell); height:var(--cell);
    background:#101827; border:1px solid #1c2736; border-radius:14px;
    position:relative; display:flex; align-items:center; justify-content:center; overflow:visible;
  }
  .cell::after{ content:""; position:absolute; inset:0; border-radius:14px; pointer-events:none;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03); }
  .cell.blocked{
    background:var(--blocked);
    background-image: repeating-linear-gradient(135deg, #1f2533 0 8px, #141925 8px 16px);
    border-color:#20283a;
  }
  .tile{
    position:absolute; inset:4px; border-radius:12px;
    border:1px solid #2a3443;
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:22px; letter-spacing:0.2px;
    box-shadow: 0 6px 16px rgba(0,0,0,0.35);
    transition: transform .15s ease, background .2s ease, border-color .2s ease, color .2s ease;
    user-select:none; -webkit-user-select:none;
  }
  .tile.sel{ outline:2px solid var(--accent); outline-offset:-2px; transform: scale(1.03); }
  .tile.spawn{ animation: pop .22s ease-out; }
  .tile.bump{ animation: bump .18s ease-out; }
  .tile.merge{ animation: merge .22s ease-in-out; }
  @keyframes pop{ from{ transform: scale(0.6); opacity:0 } to{ transform: scale(1); opacity:1 } }
  @keyframes bump{ 0%{transform:scale(1)} 50%{transform:scale(1.08)} 100%{transform:scale(1)} }
  @keyframes merge{ 0%{transform:scale(0.95)} 50%{transform:scale(1.12)} 100%{transform:scale(1)} }

  .msg{
    position:fixed; left:50%; top:56px; transform:translateX(-50%);
    background:#111a28; border:1px solid #223043; padding:8px 12px; border-radius:10px;
    font-size:13px; color:#cfe5ff; opacity:0; transition:opacity .2s;
  }
  .msg.show{ opacity:1 }

  /* 결과 팝업 + 랭킹 */
  #resultPopup { position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,0.65); z-index:999; visibility:hidden; opacity:0; transition:opacity .25s; }
  #resultPopup.show{ visibility:visible; opacity:1; }
  #resultBox { background:#161c29; padding:24px; border-radius:16px; text-align:center; min-width:280px;
    box-shadow:0 10px 28px rgba(0,0,0,0.6); }
  #resultBox h2{margin:0 0 12px;font-size:20px;}
  #resultBox p{margin:6px 0;font-size:14px;color:var(--muted);}
  #resultBox .btn{margin-top:12px;}
  #rankHeader{display:flex; align-items:center; justify-content:center; gap:8px; margin-top:10px;}
  #rankings{margin-top:10px; max-height:320px; overflow-y:auto; text-align:left; border:1px solid #2a3443; border-radius:10px;}
  .rank-item{display:flex; justify-content:space-between; gap:10px; padding:6px 10px; border-bottom:1px solid #222a3b; font-size:14px;}
  .rank-item:last-child{border-bottom:none}
  .rank-item .left{display:flex; align-items:center; gap:8px;}
  .crown{font-size:16px; line-height:1}
  .top1 .crown{filter: drop-shadow(0 0 6px rgba(255,215,0,.4));}
  .top2 .crown{filter: drop-shadow(0 0 6px rgba(192,192,192,.35));}
  .top3 .crown{filter: drop-shadow(0 0 6px rgba(205,127,50,.35));}
</style>
</head>
<body>
<header>
  <div class="row">
    <div class="stat">
      <span class="idtag" id="idView">ID: -</span>
      <span>턴: <b id="turn">0</b></span>
      <span>다음 스폰: <b id="nextSpawn">3</b></span>
      <span id="version">v1.0.0</span>
    </div>
  </div>
  <div class="row">
    <button class="btn" id="btnNew">새 게임</button>
    <button class="btn" id="btnResetId">아이디 초기화</button>
  </div>
</header>

<div id="boardWrap">
  <div id="board"></div>
</div>

<div class="msg" id="toast"></div>

<!-- 결과 팝업 -->
<div id="resultPopup">
  <div id="resultBox">
    <h2>게임 오버</h2>
    <h4>이동 가능한 블럭이 없습니다.</h4>
    <p id="finalScore"></p>
    <div id="rankHeader">
      <h3 style="margin:0;font-size:16px;">랭킹 TOP 100</h3>
    </div>
    <div id="rankings"></div>
    <button class="btn" id="btnRestart">다시 시작</button>
  </div>
</div>
<script>
(()=>{
  const GAS_URL="https://script.google.com/macros/s/AKfycby6XECWI5KSP0LcRFo_aYAKbX6C6w4izELK3nrgTlJBOdQRfnp-a0GNUCXjUmhAk_bc/exec"; 
  const COLS=5, ROWS=7;
  const INIT_TILES = 12;
  const BLOCK_MIN = 2, BLOCK_MAX = 3;
  const SPAWN_EVERY = 3;
  const SPAWN_BATCH = 3;
  const PALETTE = ["#3498db","#2ecc71","#9b59b6","#e67e22","#e74c3c",
    "#f1c40f","#1abc9c","#34495e","#ff6b6b","#8e44ad"];

  let grid=[], turn=0, untilSpawn=SPAWN_EVERY, selected=null, history=[], gameOverShown=false;
  const board=document.getElementById('board');
  const elTurn=document.getElementById('turn'), elNext=document.getElementById('nextSpawn');
  const toast=document.getElementById('toast');
  const popup=document.getElementById('resultPopup'), finalScore=document.getElementById('finalScore');
  const idView=document.getElementById('idView');
  const rankingsEl=document.getElementById('rankings');

  let playerId = localStorage.getItem("mergePlayerId");
  function askPlayerId(force=false){
    if(!playerId || force){
      let input = "";
      while(!input){
        input = prompt("플레이어 아이디를 입력하세요:");
        if(input===null){ input=""; }
      }
      playerId = input.trim();
      localStorage.setItem("mergePlayerId", playerId);
      idView.textContent = "ID: " + playerId;
      info(`아이디 설정됨: ${playerId}`);
    } else {
      idView.textContent = "ID: " + playerId;
    }
  }

  document.getElementById('btnNew').addEventListener('click',()=>newGame());
  document.getElementById('btnRestart').addEventListener('click',()=>{ popup.classList.remove('show'); newGame(); });
  document.getElementById('btnResetId').addEventListener('click',()=>{ localStorage.removeItem("mergePlayerId"); playerId=null; idView.textContent = "ID: -"; askPlayerId(true); });

  init();
  function init(){
    askPlayerId();
    board.innerHTML='';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell=document.createElement('div');
        cell.className='cell';
        cell.dataset.r=r; cell.dataset.c=c;
        cell.addEventListener('click', onTapCell);
        board.appendChild(cell);
      }
    }
    newGame();
  }

  function newGame(){
    grid=makeGrid();
    placeRandomBlocks(-1, BLOCK_MIN + ((Math.random()*(BLOCK_MAX-BLOCK_MIN+1))|0));
    placeRandomTilesAvoidingTriples(INIT_TILES, 400);
    renderAll(true);
    requestAnimationFrame(()=>{ resolveAutoMerges(); saveSnapshot(); });
    turn=0; untilSpawn=SPAWN_EVERY; selected=null; gameOverShown=false;
    elTurn.textContent='0'; elNext.textContent=String(SPAWN_EVERY);
    popup.classList.remove('show');
    checkGameOverSoon();
  }

  function makeGrid(){ return Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
  function cloneGrid(g){ return g.map(r=>r.slice()); }
  function inBounds(r,c){ return r>=0&&r<ROWS&&c>=0&&c<COLS; }
  function isEmpty(r,c){ return grid[r][c]===0; }
  function isBlocked(r,c){ return grid[r][c]===-1; }
  function isTile(r,c){ return grid[r][c]>0; }

  function placeRandomBlocks(v,count){ const E=listEmpty(); shuffle(E); for(let i=0;i<count&&i<E.length;i++) grid[E[i].r][E[i].c]=v; }
  function listEmpty(){ const out=[]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]===0) out.push({r,c}); return out; }
  function placeRandomTilesAvoidingTriples(count,maxTry=200){
    let placed=0, tries=0;
    while(placed<count && tries<maxTry){
      const E=listEmpty(); if(!E.length) break;
      const p=E[(Math.random()*E.length)|0], v=randomValue();
      grid[p.r][p.c]=v;
      if(findAnyGroupGE3()){ grid[p.r][p.c]=0; } else { placed++; }
      tries++;
    }
    if(placed<count) placeRandomTiles(count-placed);
  }
  function placeRandomTiles(count){ const E=listEmpty(); shuffle(E); for(let i=0;i<count&&i<E.length;i++) grid[E[i].r][E[i].c]=randomValue(); }
  function randomValue(){ return [1,1,1,1,3,3,9][(Math.random()*7)|0]; }
  function spawnBatch(){ for(let i=0;i<SPAWN_BATCH;i++) spawnOne(); }
  function spawnOne(){ const E=listEmpty(); if(!E.length) return false; const p=E[(Math.random()*E.length)|0]; grid[p.r][p.c]=randomValue(); drawCell(p.r,p.c,{spawn:true}); resolveAutoMerges(); return true; }

  function renderAll(spawn=false){ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) drawCell(r,c,{spawn:spawn&&isTile(r,c)}); elTurn.textContent=String(turn); elNext.textContent=String(untilSpawn); }

  function setTileColors(el, val){
    const idx = val===1 ? 0 : Math.max(1, Math.round(Math.log(val)/Math.log(3)));
    const color = PALETTE[idx % PALETTE.length];
    const isBright = isLight(color);
    el.style.background = color;
    el.style.color = isBright ? "#000" : "#fff";
    el.style.borderColor = shade(color, -20);
  }
  function isLight(hex){ const c = hex.replace('#',''); const r=parseInt(c.substr(0,2),16), g=parseInt(c.substr(2,2),16), b=parseInt(c.substr(4,2),16); const l = 0.2126*r + 0.7152*g + 0.0722*b; return l > 160; }
  function shade(hex, amt){ let c = hex.replace('#',''); let r=parseInt(c.substr(0,2),16), g=parseInt(c.substr(2,2),16), b=parseInt(c.substr(4,2),16); r=Math.max(0,Math.min(255,r+amt)); g=Math.max(0,Math.min(255,g+amt)); b=Math.max(0,Math.min(255,b+amt)); return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }

  function drawCell(r,c,opt={}){ const idx=r*COLS+c, cell=board.children[idx]; cell.classList.toggle('blocked',isBlocked(r,c)); const prev=cell.querySelector('.tile'); if(prev) prev.remove(); const v=grid[r][c]; if(v>0){ const t=document.createElement('div'); t.className='tile'; t.textContent=v; t.dataset.val=v; if(opt.spawn) t.classList.add('spawn'); setTileColors(t, v); cell.appendChild(t); } }

  function highlightSelection(){ for(const cell of board.children){ const t=cell.querySelector('.tile'); if(t) t.classList.remove('sel'); } if(selected){ const tile=board.children[selected.r*COLS+selected.c].querySelector('.tile'); if(tile) tile.classList.add('sel'); } }

  function onTapCell(){
    const r=+this.dataset.r, c=+this.dataset.c;
    if(isTile(r,c)){ selected={r,c}; highlightSelection(); return; }
    if(isEmpty(r,c) && selected){
      const from={...selected}, to={r,c}, val=grid[from.r][from.c];
      const path=findPathViaEmpties(from,to);
      if(!path){ info('경로 막힘','err'); return; }
      if(!destAdjacentSame(to,val)){ info('옆에 같은 숫자 필요','warn'); return; }
      const gsize=groupSizeIfMoved(from,to,val);
      if(gsize<2){ info('이동 불가','err'); return; }
      const currentGroup=floodSame(from.r,from.c,val);
      if(currentGroup.length===2 && gsize<3){ info('붙은 쌍은 분리 불가','err'); return; }
      moveTile(from,to);
      if(gsize>=3) resolveAutoMerges(to);
      turn++; untilSpawn--; if(untilSpawn===0){ spawnBatch(); untilSpawn=SPAWN_EVERY; }
      saveSnapshot(); elTurn.textContent=String(turn); elNext.textContent=String(untilSpawn);
      selected=null; highlightSelection(); checkGameOverSoon();
    }
  }

  function findPathViaEmpties(from,to){
    const q=[from], prev=Array.from({length:ROWS},()=>Array(COLS).fill(null)), vis=Array.from({length:ROWS},()=>Array(COLS).fill(false));
    vis[from.r][from.c]=true;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const cur=q.shift();
      for(const [dr,dc] of dirs){
        const nr=cur.r+dr, nc=cur.c+dc;
        if(!inBounds(nr,nc)||vis[nr][nc]) continue;
        if(nr===to.r && nc===to.c){ if(!isEmpty(nr,nc)) continue; }
        else if(isBlocked(nr,nc)||isTile(nr,nc)){ continue; }
        vis[nr][nc]=true; prev[nr][nc]=cur;
        if(nr===to.r && nc===to.c){
          const path=[]; let x={r:nr,c:nc};
          while(x){ path.push(x); x=prev[x.r][x.c]; }
          path.reverse();
          return path;
        }
        q.push({r:nr,c:nc});
      }
    }
    return null;
  }

  function moveTile(from,to){
    const v=grid[from.r][from.c];
    grid[from.r][from.c]=0; grid[to.r][to.c]=v;
    drawCell(from.r,from.c); drawCell(to.r,to.c);
    const tCell=board.children[to.r*COLS+to.c].querySelector('.tile');
    if(tCell){ tCell.classList.add('bump'); setTimeout(()=>tCell.classList.remove('bump'),200); }
  }

  function destAdjacentSame(to,val){ return [[1,0],[-1,0],[0,1],[0,-1]].some(([dr,dc])=>inBounds(to.r+dr,to.c+dc) && grid[to.r+dr][to.c+dc]===val); }
  function floodSame(sr,sc,val,g=grid){ const vis=Array.from({length:ROWS},()=>Array(COLS).fill(false)), q=[{r:sr,c:sc}], out=[]; vis[sr][sc]=true; while(q.length){ const {r,c}=q.shift(); out.push({r,c}); for(const [dr,dc] of [[1,0],[0,1],[-1,0],[0,-1]]){ const nr=r+dr,nc=c+dc; if(inBounds(nr,nc)&&!vis[nr][nc]&&g[nr][nc]===val){ vis[nr][nc]=true; q.push({r:nr,c:nc}); } } } return out; }
  function groupSizeIfMoved(from,to,val){ const tmp=cloneGrid(grid); tmp[from.r][from.c]=0; tmp[to.r][to.c]=val; return floodSame(to.r,to.c,val,tmp).length; }

  function resolveAutoMerges(forcePivot=null){ let merged=false; while(true){ const f=findAnyGroupGE3(); if(!f) break; const {val,group}=f; const pivot=forcePivot || group[0]; const absorb=group.filter(p=>(p.r!==pivot.r||p.c!==pivot.c)).slice(0,2); for(const p of absorb){ grid[p.r][p.c]=0; drawCell(p.r,p.c); } grid[pivot.r][pivot.c]=val*3; const tCell = board.children[pivot.r*COLS+pivot.c].querySelector('.tile'); if(tCell){ tCell.classList.add('merge'); setTimeout(()=>tCell.classList.remove('merge'),240); } drawCell(pivot.r,pivot.c); merged=true; forcePivot=null; } if(merged) saveSnapshot(); }

  function findAnyGroupGE3(){ const seen=Array.from({length:ROWS},()=>Array(COLS).fill(false)); for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){ const v=grid[r][c]; if(v<=0||seen[r][c]) continue; const comp=floodSame(r,c,v); for(const p of comp) seen[p.r][p.c]=true; if(comp.length>=3) return {val:v,group:comp}; } return null; }

  function legalMoveExistsForTile(r,c){ const v=grid[r][c]; const currentGroup=floodSame(r,c,v); for(let rr=0;rr<ROWS;rr++)for(let cc=0;cc<COLS;cc++){ if(!isEmpty(rr,cc)) continue; const to={r:rr,c:cc}; const path=findPathViaEmpties({r,c},to); if(!path) continue; if(!destAdjacentSame(to,v)) continue; const gsize=groupSizeIfMoved({r,c},to,v); if(gsize<2) continue; if(currentGroup.length===2 && gsize<3) continue; return true; } return false; }
  function hasAnyMoves(){ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ if(grid[r][c]>0 && legalMoveExistsForTile(r,c)) return true; } return false; }
  function checkGameOverSoon(){ setTimeout(()=>{ if(!gameOverShown && !hasAnyMoves()){ gameOverShown=true; const total=grid.flat().filter(v=>v>0).reduce((a,b)=>a+b,0); showResult(total); } },30); }

  function saveSnapshot(){ history.push({grid:cloneGrid(grid),turn,untilSpawn}); if(history.length>50) history.shift(); }
  function info(t,k){ toast.textContent=t; toast.style.color = k==='err' ? 'var(--err)' : (k==='warn' ? 'var(--warn)' : 'var(--fg)'); toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),1200); }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }

  async function showResult(total){
    finalScore.textContent = `${playerId}의 최종 점수: ${total}`;
    try{
      await fetch(`${GAS_URL}?action=submit&id=${encodeURIComponent(playerId)}&score=${encodeURIComponent(total)}`, {mode:'no-cors'});
      const res = await fetch(`${GAS_URL}?action=get`, {cache:'no-cache'});
      let data=[]; try{ data = await res.json(); }catch(e){ }
      renderRanking(Array.isArray(data) ? data.slice(0,100) : []);
    }catch(e){ renderRanking([]); }
    popup.classList.add('show');
  }

  function renderRanking(rows){
    rankingsEl.innerHTML = "";
    if(!rows || rows.length===0){ const empty=document.createElement('div'); empty.style.padding='10px'; empty.textContent='랭킹 데이터를 불러오지 못했습니다.'; rankingsEl.appendChild(empty); return; }
    rows.forEach((row,i)=>{ const item=document.createElement('div'); item.className='rank-item' + (i===0?' top1': i===1?' top2': i===2?' top3':''); const left=document.createElement('div'); left.className='left'; const crown=document.createElement('span'); crown.className='crown'; crown.textContent = i===0?'👑': i===1?'👑': i===2?'👑':''; left.appendChild(crown); const name=document.createElement('span'); name.textContent = `${i+1}. ${row.id ?? row.name ?? 'unknown'}`; left.appendChild(name); const score=document.createElement('span'); score.textContent = `${row.score ?? row.point ?? 0}`; item.appendChild(left); item.appendChild(score); rankingsEl.appendChild(item); });
  }

})();
</script>
</body>
</html>
