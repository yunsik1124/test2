<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>3매칭 머지 프로토타입 (5x7) - 총합본</title>
<style>
  :root{
    --cell:60px; --gap:6px; --cols:5; --rows:7;
    --board-w: calc(var(--cols)*(var(--cell)) + (var(--cols)-1)*var(--gap));
    --board-h: calc(var(--rows)*(var(--cell)) + (var(--rows)-1)*var(--gap));
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:#0b0f14;color:#e8f0ff;font-family:system-ui,Segoe UI,Arial,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;gap:10px;padding:12px;
    -webkit-tap-highlight-color: transparent; touch-action: manipulation;
  }
  h1{font-size:16px;margin:6px 0 0;opacity:.9}
  #ui{display:flex;gap:8px;align-items:center;font-size:12px;opacity:.8}
  #board-wrap{position:relative;width:var(--board-w);height:var(--board-h)}
  #board{
    position:absolute;left:0;top:0; z-index:10;
    display:grid;grid-template-columns:repeat(var(--cols), var(--cell));
    grid-template-rows:repeat(var(--rows), var(--cell));
    gap:var(--gap);
  }
  .cell{
    width:var(--cell);height:var(--cell);
    background:#111723;border:1px solid #1c2433;border-radius:10px;
    display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;
  }
  .cell.blocked{ background:#202733; }
  .cell.blocked::after{ content:"✕"; color:#8090a6;font-size:18px;opacity:.6; }
  .tile{
    position:absolute;left:0;top:0;width:var(--cell);height:var(--cell);
    display:flex;align-items:center;justify-content:center;
    border-radius:12px;font-weight:800;font-size:18px;letter-spacing:.5px;
    color:#0b0f14; user-select:none; pointer-events:auto;
    transform:translate3d(0,0,0) scale(1); transition:transform .18s cubic-bezier(.2, .9, .2, 1);
    box-shadow:0 6px 16px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.08);
  }
  .tile[data-v="1"]{background:#9fd3ff}
  .tile[data-v="2"]{background:#7ee7c8}
  .tile[data-v="3"]{background:#ffe08a}
  .tile[data-v="4"]{background:#ffb3b3}
  .tile[data-v="5"]{background:#d4b5ff}
  .tile[data-v="6"]{background:#ffdfdf}
  .tile.selected{outline:3px solid #66ffd1; outline-offset:-3px; z-index:20}

  /* 스폰 & 도착(매칭 실패) 공용 ‘띠용’ */
  @keyframes pop {
    0%{transform:scale(.2)}
    60%{transform:scale(1.12)}
    100%{transform:scale(1)}
  }
  .pop{animation:pop .22s cubic-bezier(.2,1.2,.2,1) forwards}

  /* 머지 시 살짝 크게 튀기는 액션 */
  @keyframes merge-bounce {
    0%{transform:scale(1)}
    35%{transform:scale(1.15)}
    100%{transform:scale(1)}
  }
  .merge-bounce{animation:merge-bounce .26s cubic-bezier(.2,1.2,.2,1) forwards}

  /* 제거되는 타일 페이드 */
  .fade-out{transition:opacity .18s ease, transform .18s ease; opacity:0; transform:scale(.6)}

  /* 경로 라인 (단일 얇은 선, 끊김 없음) */
  #path-layer{
    position:absolute;left:0;top:0;width:100%;height:100%;
    pointer-events:none; z-index:30;
  }
  .path-stroke{
    fill:none; stroke:#e8f0ff; stroke-width:2; stroke-linecap:round; stroke-linejoin:round;
    filter: drop-shadow(0 0 2px rgba(232,240,255,.6));
    opacity:.9; transition:opacity .4s ease;
  }
  .path-fade{opacity:0}

  .hint{font-size:12px;opacity:.7;margin-top:2px}
  button{
    background:#1a2533;color:#e8f0ff;border:1px solid #2a394f;border-radius:8px;padding:8px 10px;
    cursor:pointer;font-weight:700
  }
  button:active{transform:translateY(1px)}
</style>
</head>
<body>
  <h1>3매칭 머지 (5×7) — 총합본</h1>
  <div id="ui">
    <button id="resetBtn">리셋</button>
    <span>턴: <b id="turn">0</b></span>
    <span>다음 스폰까지: <b id="spawnIn">5</b>턴</span>
  </div>
  <div id="board-wrap">
    <svg id="path-layer" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
    <div id="board"></div>
  </div>
  <div class="hint">규칙: 빈칸 경로가 있어야 이동 가능. 도착 지점의 상하좌우에 같은 숫자가 최소 1개 있어야 이동 허용. 이동 후 3+ 연결이면 즉시 머지.</div>

<script>
(() => {
  const COLS = 5, ROWS = 7;
  const NEW_TILE_VALUES = [1,1,1,2,2,3]; // 새로 나오는 값 분포
  const INITIAL_TILES = 10; // 초기 생성 수
  const BLOCKED_MIN = 2, BLOCKED_MAX = 3;
  const TURNS_PER_SPAWN = 5; // 5턴마다 새 블록 4~5개 생성

  const boardEl = document.getElementById('board');
  const pathLayer = document.getElementById('path-layer');
  const turnEl = document.getElementById('turn');
  const spawnInEl = document.getElementById('spawnIn');

  // ✅ 안전한 ID 생성 폴백
  const genId = () => {
    try { if (crypto && crypto.randomUUID) return crypto.randomUUID(); } catch(e){}
    return 't-' + Math.random().toString(36).slice(2) + Date.now().toString(36);
  };

  // 상태
  let grid = createEmpty();
  let blocked = new Set(); // "r,c"
  let tiles = new Map(); // id -> {id, r, c, v, el}
  let selectedId = null;
  let turn = 0, turnsUntilSpawn = TURNS_PER_SPAWN;

  // 유틸
  const key = (r,c)=> `${r},${c}`;
  const inBounds = (r,c)=> r>=0 && r<ROWS && c>=0 && c<COLS;
  const neighbors4 = (r,c)=> [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([rr,cc])=>inBounds(rr,cc));

  function createEmpty(){
    return Array.from({length:ROWS},()=> Array.from({length:COLS},()=> null));
  }

  function cellCenterPx(r,c){
    const styles = getComputedStyle(document.documentElement);
    const cell = parseInt(styles.getPropertyValue('--cell'));
    const gap = parseInt(styles.getPropertyValue('--gap'));
    const x = c*(cell+gap) + cell/2;
    const y = r*(cell+gap) + cell/2;
    return {x,y};
  }

  function gridToPx(r,c){
    const styles = getComputedStyle(document.documentElement);
    const cell = parseInt(styles.getPropertyValue('--cell'));
    const gap = parseInt(styles.getPropertyValue('--gap'));
    const x = c*(cell+gap);
    const y = r*(cell+gap);
    return {x,y};
  }

  function drawBoard(){
    boardEl.innerHTML = '';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        if(blocked.has(key(r,c))) cell.classList.add('blocked');
        cell.dataset.r = r; cell.dataset.c = c;
        boardEl.appendChild(cell);
      }
    }
    // 타일 DOM 추가
    tiles.forEach(t => {
      boardEl.appendChild(t.el);
      placeTileElement(t);
    });
  }

  // ✅ 셀 클릭 이벤트 위임(겹침 이슈 방지)
  boardEl.addEventListener('click', (e)=>{
    const cell = e.target.closest('.cell');
    if(!cell || !boardEl.contains(cell)) return;
    onCellClick(+cell.dataset.r, +cell.dataset.c);
  });

  function makeTileEl(t){
    const el = document.createElement('div');
    el.className = 'tile pop';
    el.textContent = t.v;
    el.dataset.v = t.v;
    el.style.zIndex = 15;
    el.addEventListener('click', (e)=>{ e.stopPropagation(); onTileClick(t.id); });
    return el;
  }

  function placeTileElement(t){
    const {x,y} = gridToPx(t.r,t.c);
    t.el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(1)`;
  }

  function randomChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function randomEmptyCell(){
    const empties = [];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      if(!grid[r][c] && !blocked.has(key(r,c))) empties.push([r,c]);
    }
    return empties.length? randomChoice(empties) : null;
  }

  function addRandomTile(value=null, withSpawnAnim=true){
    const pos = randomEmptyCell();
    if(!pos) return false;
    const [r,c] = pos;
    const v = value ?? randomChoice(NEW_TILE_VALUES);
    const id = genId();                // ✅ 폴백 사용
    const tile = {id,r,c,v,el:null};
    grid[r][c] = id;
    tiles.set(id, tile);
    tile.el = makeTileEl(tile);
    if(!withSpawnAnim) tile.el.classList.remove('pop');
    tile.el.textContent = v;
    tile.el.dataset.v = v;
    boardEl.appendChild(tile.el);
    placeTileElement(tile);
    return true;
  }

  function clusterSame(r,c, v=null){
    const id = grid[r][c];
    if(!id) return [];
    const baseV = v ?? tiles.get(id).v;
    const seen = new Set();
    const q = [[r,c]];
    const res = [];
    while(q.length){
      const [rr,cc] = q.shift();
      const k = key(rr,cc);
      if(seen.has(k)) continue;
      seen.add(k);
      const tid = grid[rr][cc];
      if(!tid) continue;
      const tv = tiles.get(tid).v;
      if(tv !== baseV) continue;
      res.push([rr,cc]);
      for(const [nr,nc] of neighbors4(rr,cc)) q.push([nr,nc]);
    }
    return res;
  }

  function hasAdjSameAt(r,c,v){
    return neighbors4(r,c).some(([rr,cc])=>{
      const id = grid[rr][cc];
      return id && tiles.get(id).v===v;
    });
  }

  // BFS 경로: 시작(r0,c0) -> 도착(r1,c1)까지, 중간은 빈칸만 통과 가능
  function bfsPath(r0,c0, r1,c1){
    const q=[[r0,c0]];
    const prev = new Map();
    const sk = key(r0,c0);
    prev.set(sk, null);
    const passable = (r,c)=> (r===r0 && c===c0) || (!grid[r][c] && !blocked.has(key(r,c)));
    while(q.length){
      const [r,c]=q.shift();
      if(r===r1 && c===c1) break;
      for(const [nr,nc] of neighbors4(r,c)){
        if(!passable(nr,nc)) continue;
        const k=key(nr,nc);
        if(prev.has(k)) continue;
        prev.set(k, [r,c]);
        q.push([nr,nc]);
      }
    }
    const endK = key(r1,c1);
    if(!prev.has(endK)) return null;
    const path = [];
    let cur = [r1,c1];
    while(cur){
      path.push(cur);
      cur = prev.get(key(cur[0],cur[1]));
    }
    path.reverse();
    return path;
  }

  function deselect(){
    if(!selectedId) return;
    const t = tiles.get(selectedId);
    if(t) t.el.classList.remove('selected');
    selectedId = null;
  }

  function onTileClick(id){
    if(selectedId === id){ deselect(); return; }
    deselect();
    selectedId = id;
    const t = tiles.get(id);
    if(t) t.el.classList.add('selected');
  }

  function onCellClick(r,c){
    if(!selectedId) return;
    if(grid[r][c]) return; // 빈칸만 목적지
    if(blocked.has(key(r,c))) return;

    const t = tiles.get(selectedId);
    if(!t) return;

    const path = bfsPath(t.r, t.c, r, c);
    if(!path){ pulseDenied(); return; }

    // 목적지 인접 같은 숫자 ≥1 이어야 이동 허용
    if(!hasAdjSameAt(r,c,t.v)){ pulseDenied(); return; }

    performMoveWithPath(t, path);
  }

  function pulseDenied(){
    if(!selectedId) return;
    const el = tiles.get(selectedId)?.el;
    if(!el) return;
    el.animate([
      {transform:el.style.transform + ' rotate(0deg)'},
      {transform:el.style.transform + ' rotate(-3deg)'},
      {transform:el.style.transform + ' rotate(3deg)'},
      {transform:el.style.transform + ' rotate(0deg)'},
    ], {duration:140, easing:'ease-out'});
  }

  function drawPathPolyline(path){
    const styles = getComputedStyle(document.documentElement);
    const cell = parseInt(styles.getPropertyValue('--cell'));
    const gap = parseInt(styles.getPropertyValue('--gap'));
    const W = COLS*(cell) + (COLS-1)*gap;
    const H = ROWS*(cell) + (ROWS-1)*gap;

    pathLayer.setAttribute('viewBox', `0 0 ${W} ${H}`);

    const pts = path.map(([r,c])=>{
      const {x,y} = cellCenterPx(r,c);
      return `${x},${y}`;
    }).join(' ');

    const pl = document.createElementNS('http://www.w3.org/2000/svg','polyline');
    pl.setAttribute('points', pts);
    pl.setAttribute('class','path-stroke');
    pathLayer.appendChild(pl);

    setTimeout(()=> pl.classList.add('path-fade'), 1600);
    setTimeout(()=> pl.remove(), 2100);
  }

  function performMoveWithPath(t, path){
    drawPathPolyline(path);
    const [destR, destC] = path[path.length-1];

    grid[t.r][t.c] = null;
    grid[destR][destC] = t.id;

    boardEl.style.pointerEvents = 'none';

    const {x,y} = gridToPx(destR,destC);
    t.el.style.transition = 'transform .22s cubic-bezier(.2, .9, .2, 1)';
    t.el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(1)`;

    const onDone = () => {
      t.r = destR; t.c = destC;
      const cluster = clusterSame(destR,destC);
      if(cluster.length >= 3){
        doMerge(destR,destC, cluster);
      }else{
        t.el.classList.remove('pop'); void t.el.offsetWidth;
        t.el.classList.add('pop');
      }
      afterTurn();
      deselect();
      boardEl.style.pointerEvents = '';
      t.el.removeEventListener('transitionend', onDone);
    };

    // ✅ transitionend 누락 대비 폴백
    const failSafe = setTimeout(()=> onDone(), 320);

    t.el.addEventListener('transitionend', ()=>{
      clearTimeout(failSafe);
      onDone();
    }, {once:true});
  }

  function doMerge(destR,destC, cluster){
    const destId = grid[destR][destC];
    const baseV = tiles.get(destId).v;

    for(const [r,c] of cluster){
      const id = grid[r][c];
      if(id === destId) continue;
      const tile = tiles.get(id);
      if(!tile) continue;
      tile.el.classList.add('fade-out');
      grid[r][c] = null;
      setTimeout(()=>{ tile.el.remove(); tiles.delete(id); }, 180);
    }
    const destTile = tiles.get(destId);
    destTile.v = baseV + 1;
    destTile.el.dataset.v = destTile.v;
    destTile.el.textContent = destTile.v;
    destTile.el.classList.remove('merge-bounce'); void destTile.el.offsetWidth;
    destTile.el.classList.add('merge-bounce');

    setTimeout(()=>{
      let changed = true;
      while(changed){
        changed = false;
        const cl = clusterSame(destTile.r, destTile.c);
        if(cl.length >= 3){
          const v0 = destTile.v;
          for(const [r,c] of cl){
            const id = grid[r][c];
            if(id === destTile.id) continue;
            const rem = tiles.get(id);
            if(!rem) continue;
            rem.el.classList.add('fade-out');
            grid[r][c] = null;
            setTimeout(()=>{ rem.el.remove(); tiles.delete(id); }, 180);
          }
          destTile.v = v0 + 1;
          destTile.el.dataset.v = destTile.v;
          destTile.el.textContent = destTile.v;
          destTile.el.classList.remove('merge-bounce'); void destTile.el.offsetWidth;
          destTile.el.classList.add('merge-bounce');
          changed = true;
        }
      }
    }, 200);
  }

  function afterTurn(){
    turn++; turnsUntilSpawn--;
    if(turnsUntilSpawn<=0){
      const count = 4 + Math.floor(Math.random()*2);
      for(let i=0;i<count;i++) addRandomTile();
      turnsUntilSpawn = TURNS_PER_SPAWN;
      squashImmediateTriples();
    }
    updateUI();
    if(!anyMoveAvailable()){
      setTimeout(()=> alert('이동 불가! 게임 오버'), 10);
    }
  }

  function updateUI(){
    turnEl.textContent = turn;
    spawnInEl.textContent = turnsUntilSpawn;
  }

  function squashImmediateTriples(maxTries=20){
    for(let tries=0;tries<maxTries;tries++){
      let ok = true;
      outer: for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const id = grid[r][c];
          if(!id) continue;
          const cl = clusterSame(r,c);
          if(cl.length>=3){ ok=false; break outer; }
        }
      }
      if(ok) return;
      const filled=[];
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]) filled.push([r,c]);
      if(!filled.length) return;
      const [rr,cc] = randomChoice(filled);
      const id = grid[rr][cc];
      const t = tiles.get(id);
      t.v = randomChoice(NEW_TILE_VALUES);
      t.el.dataset.v = t.v;
      t.el.textContent = t.v;
    }
  }

  function anyMoveAvailable(){
    for(const t of tiles.values()){
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        if(grid[r][c] || blocked.has(key(r,c))) continue;
        if(!hasAdjSameAt(r,c,t.v)) continue;
        const path = bfsPath(t.r,t.c,r,c);
        if(path) return true;
      }
    }
    return false;
  }

  function resetAll(){
    grid = createEmpty();
    tiles.clear();
    blocked.clear();
    selectedId = null;
    turn = 0; turnsUntilSpawn = TURNS_PER_SPAWN;

    const toBlock = BLOCKED_MIN + Math.floor(Math.random()*(BLOCKED_MAX-BLOCKED_MIN+1));
    let tries=0;
    while(blocked.size < toBlock && tries<200){
      const r = Math.floor(Math.random()*ROWS), c = Math.floor(Math.random()*COLS);
      if(blocked.has(key(r,c))) { tries++; continue; }
      blocked.add(key(r,c));
    }

    drawBoard();

    for(let i=0;i<INITIAL_TILES;i++) addRandomTile();
    squashImmediateTriples(50);
    updateUI();
  }

  document.getElementById('resetBtn').addEventListener('click', ()=> resetAll());
  resetAll();
})();
</script>
</body>
</html>
