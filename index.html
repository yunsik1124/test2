<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>5x7 머지 게임</title>
<style>
  :root{
    --cols: 5; --rows: 7;
    --cell: 64px; --gap: 8px;
    --board-w: calc(var(--cols)*var(--cell) + (var(--cols)-1)*var(--gap));
    --board-h: calc(var(--rows)*var(--cell) + (var(--rows)-1)*var(--gap));
    --bg: #0b0f14; --fg:#e8f0ff; --muted:#7f8da3;
    --tile:#1a2230; --tile2:#243044; --accent:#59ffa1; --warn:#ff8a65;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display:flex;flex-direction:column;align-items:center;gap:12px;padding:16px;
    -webkit-tap-highlight-color: transparent;
  }
  header{width:var(--board-w);display:flex;justify-content:space-between;align-items:center;gap:8px}
  h1{font-size:16px;margin:0;color:var(--muted);font-weight:600}
  .controls{display:flex;gap:8px;align-items:center}
  button{
    background:#1d283a;color:var(--fg);border:1px solid #2e3b53;border-radius:10px;
    padding:10px 14px;font-weight:600;cursor:pointer;transition:.15s transform,.15s opacity;
  }
  button:active{transform:scale(.98)}
  .pill{font-size:12px;padding:6px 10px;border-radius:999px;background:#162033;border:1px solid #2a3a53;color:#b8c5db}
  #boardWrap{
    position:relative;width:var(--board-w);height:var(--board-h);
  }
  #board{
    position:absolute;inset:0;
    display:grid;
    grid-template-columns: repeat(var(--cols), var(--cell));
    grid-template-rows: repeat(var(--rows), var(--cell));
    gap: var(--gap);
  }
  .cell{
    width:var(--cell); height:var(--cell);
    border-radius:14px; background:#0f141e; border:1px dashed #23314855;
    display:flex; align-items:center; justify-content:center; position:relative;
    overflow:visible;
  }
  .cell.blocked{
    background: #1c0f12;
    border:1px solid #3b1b21;
    box-shadow: inset 0 0 0 2px #3b1b21aa;
  }
  .tile{
    width:calc(var(--cell) - 6px); height:calc(var(--cell) - 6px);
    border-radius:12px; display:flex; align-items:center; justify-content:center;
    background: linear-gradient(180deg, var(--tile), var(--tile2));
    border:1px solid #3b4b66;
    box-shadow: 0 6px 16px #00000055, inset 0 0 0 2px #ffffff0d;
    font-weight:900; font-size:20px; letter-spacing:.5px;
    transform: scale(1); transition: transform .12s;
    user-select:none;
  }
  .tile.selected{outline: 3px solid #63b3ff; transform: scale(1.05)}
  .tile.pop{animation: pop .22s ease-out}
  @keyframes pop{0%{transform:scale(.6)}70%{transform:scale(1.08)}100%{transform:scale(1)}}
  .tile.merge{animation: merge .28s ease-in-out}
  @keyframes merge{0%{transform:scale(1)}50%{transform:scale(1.18)}100%{transform:scale(1)}}

  /* 플로팅 토큰 */
  .floatToken{
    position:absolute; pointer-events:none; font-weight:800; font-size:14px;
    background:#0f1b2a; border:1px solid #2b3a52; color:#cfe3ff;
    padding:4px 8px; border-radius:999px; opacity:0; transform:translate(-50%,-50%);
    animation: floatUp 2s ease-out forwards;
  }
  @keyframes floatUp{
    0%{opacity:0; transform:translate(-50%,-20%); filter:blur(1px)}
    10%{opacity:1}
    100%{opacity:0; transform:translate(-50%,-120%); filter:blur(3px)}
  }

  /* SVG 라인 */
  #fx{
    position:absolute; inset:0; pointer-events:none;
  }
  .fadeLine{stroke:#75c6ff; stroke-width:3; stroke-linecap:round; opacity:1;
    filter: drop-shadow(0 0 4px #75c6ff88);
    animation: fadeout 2s ease-out forwards;
  }
  @keyframes fadeout{to{opacity:0}}

  /* 하단 도움말 */
  .help{width:var(--board-w); color:#9db0c9; font-size:12px; line-height:1.5}
  .help code{background:#0f1929; padding:2px 6px; border-radius:6px; border:1px solid #1f2d46}
</style>
</head>
<body>
  <header>
    <h1>5×7 머지</h1>
    <div class="controls">
      <span class="pill">턴: <b id="turn">0</b></span>
      <span class="pill">다음 스폰까지: <b id="spawnIn">5</b></span>
      <button id="resetBtn">리셋</button>
    </div>
  </header>

  <div id="boardWrap">
    <svg id="fx"></svg>
    <div id="board" aria-label="game board"></div>
  </div>

  <div class="help">
    <p>규칙</p>
    <ul>
      <li>같은 숫자 <b>반경 1칸</b>에 붙도록 <b>직선(가로/세로)</b>으로만 이동할 수 있어. 경로 중간은 전부 빈칸이어야 함.</li>
      <li>같은 숫자 3개 이상이 붙으면 <b>병합</b>되고 수가 <b>3배</b>가 돼.</li>
      <li>매 <b>5턴</b>마다 새 블록이 <b>4~5개</b> 랜덤 등장.</li>
      <li>리셋할 때마다 <b>사용불가 슬롯</b>이 3~4칸 랜덤 배치.</li>
      <li>더 이상 이동할 수 없으면 <b>게임 오버</b>.</li>
    </ul>
    <p><code>블록 → 빈칸</code> 순서로 탭(또는 클릭)해 이동해봐.</p>
  </div>

<script>
(() => {
  const COLS = 5, ROWS = 7;
  const BOARD = document.getElementById('board');
  const FX = document.getElementById('fx');
  const turnEl = document.getElementById('turn');
  const spawnInEl = document.getElementById('spawnIn');
  const resetBtn = document.getElementById('resetBtn');

  /** 그리드: {val:number|null, blocked:boolean} */
  let grid, turn, toNextSpawn, selected = null;

  const rand = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const idx = (r,c)=> r*COLS+c;
  const inBounds = (r,c)=> r>=0 && r<ROWS && c>=0 && c<COLS;
  const neighbors4 = (r,c)=> [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([rr,cc])=>inBounds(rr,cc));

  function init(reseedObstacles=true){
    grid = Array.from({length:ROWS}, _ => Array.from({length:COLS}, _ => ({val:null, blocked:false})));
    turn = 0; toNextSpawn = 5;
    if(reseedObstacles){
      const blocks = rand(3,4);
      let placed=0;
      while(placed<blocks){
        const r = rand(0,ROWS-1), c = rand(0,COLS-1);
        if(!grid[r][c].blocked && grid[r][c].val===null){
          grid[r][c].blocked = true; placed++;
        }
      }
    }
    // 초기 블록 몇 개 배치
    seedRandomTiles(rand(6,8));
    render();
    updateHUD();
  }

  function seedRandomTiles(n){
    const empties = emptyCells();
    shuffle(empties);
    const count = Math.min(n, empties.length);
    for(let i=0;i<count;i++){
      const [r,c] = empties[i];
      grid[r][c].val = pickStartValue();
      spawnPopAt(r,c);
    }
    avoidInitialTriples();
  }

  function pickStartValue(){
    // 시작 값은 1,2,3에 가중치
    const bag = [1,1,1,2,2,3];
    return bag[rand(0,bag.length-1)];
  }

  function avoidInitialTriples(){
    // 시작 시 동일 숫자 3+ 인접 군집이 생기면 값을 재뽑아 약하게 섞기
    let changed = true; let guard = 0;
    while(changed && guard++<10){
      changed=false;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const v = grid[r][c].val;
          if(v==null) continue;
          const size = floodCount(r,c,v);
          if(size>=3){
            grid[r][c].val = pickStartValue(); // 한 곳만 살짝 섞기
            changed=true;
          }
        }
      }
    }
  }

  function floodCount(sr,sc,val){
    const q=[[sr,sc]]; const seen=new Set([idx(sr,sc)]);
    let cnt=0;
    while(q.length){
      const [r,c]=q.pop(); cnt++;
      for(const [rr,cc] of neighbors4(r,c)){
        if(!seen.has(idx(rr,cc)) && grid[rr][cc].val===val) { seen.add(idx(rr,cc)); q.push([rr,cc]); }
      }
    }
    return cnt;
  }

  function emptyCells(){
    const res=[];
    for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
      if(!grid[r][c].blocked && grid[r][c].val===null) res.push([r,c]);
    }
    return res;
  }

  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=rand(0,i);[a[i],a[j]]=[a[j],a[i]]} return a;}

  function render(){
    BOARD.innerHTML='';
    BOARD.style.setProperty('--cols', COLS);
    BOARD.style.setProperty('--rows', ROWS);
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = document.createElement('div');
        cell.className='cell'+(grid[r][c].blocked?' blocked':'');
        cell.dataset.r=r; cell.dataset.c=c;
        if(grid[r][c].val!=null){
          const t = document.createElement('div');
          t.className='tile';
          t.textContent = grid[r][c].val;
          if(selected && selected.r==r && selected.c==c) t.classList.add('selected');
          cell.appendChild(t);
        }
        cell.addEventListener('click', onCellClick);
        BOARD.appendChild(cell);
      }
    }
  }

  function centerOf(rc){
    const rect = BOARD.getBoundingClientRect();
    const cellSize = parseFloat(getComputedStyle(BOARD).getPropertyValue('grid-template-columns').split(' ')[0]);
    const gap = parseFloat(getComputedStyle(BOARD).gap) || parseFloat(getComputedStyle(BOARD).rowGap);
    const [r,c] = rc;
    const x = c*(cellSize+gap)+cellSize/2;
    const y = r*(cellSize+gap)+cellSize/2;
    return {x,y};
  }

  function onCellClick(e){
    const r = +e.currentTarget.dataset.r;
    const c = +e.currentTarget.dataset.c;
    const cell = grid[r][c];

    if(cell.blocked) return;

    if(cell.val!=null){
      // 선택 토글
      if(selected && selected.r===r && selected.c===c){
        selected=null; render(); return;
      }
      selected = {r,c};
      render();
      return;
    }

    // 빈칸 클릭: 선택된 블록이 있어야 함
    if(!selected) return;
    const {r:sr,c:sc} = selected;
    if(!canMove(sr,sc,r,c)) {
      flashPath(sr,sc,r,c,false);
      shakeAt(r,c);
      return;
    }
    performMove(sr,sc,r,c);
  }

  function pathClear(sr,sc,dr,dc){
    if(sr===dr){
      const c1 = Math.min(sc,dc)+1, c2=Math.max(sc,dc)-1;
      for(let c=c1;c<=c2;c++){ if(grid[sr][c].val!=null || grid[sr][c].blocked) return false; }
      return true;
    } else if(sc===dc){
      const r1 = Math.min(sr,dr)+1, r2=Math.max(sr,dr)-1;
      for(let r=r1;r<=r2;r++){ if(grid[r][sc].val!=null || grid[r][sc].blocked) return false; }
      return true;
    }
    return false; // 직선만 허용
  }

  function destNextToSame(dr,dc,val, sr,sc){
    // 목적지 기준 상하좌우 중에 같은 숫자 존재해야 함 (이동 후 상태 가정: src는 비게 됨)
    for(const [rr,cc] of neighbors4(dr,dc)){
      if(rr===sr && cc===sc) continue; // 소스와 직접 맞닿는 경우라도 이동 후 소스는 비어있음
      if(grid[rr][cc].val===val) return true;
    }
    return false;
  }

  function canMove(sr,sc,dr,dc){
    if(!(inBounds(sr,sc)&&inBounds(dr,dc))) return false;
    if(grid[dr][dc].blocked || grid[dr][dc].val!=null) return false;
    if(!pathClear(sr,sc,dr,dc)) return false;
    const v = grid[sr][sc].val;
    if(v==null) return false;
    if(!destNextToSame(dr,dc,v,sr,sc)) return false;
    return true;
  }

  function performMove(sr,sc,dr,dc){
    const v = grid[sr][sc].val;
    grid[sr][sc].val = null;
    grid[dr][dc].val = v;
    selected = null;

    // 이펙트: 라인 + 플로팅 토큰
    flashPath(sr,sc,dr,dc,true);
    floatTokenAtMid(sr,sc,dr,dc, v);

    render();
    // 병합 판정
    const merged = tryMergeFrom(dr,dc);
    // 이동 후 매칭이 안될 때: 생성 pop과 같은 액션
    if(!merged) spawnPopAt(dr,dc);

    // 턴 처리
    advanceTurn();

    // 게임오버 체크
    if(!hasAnyValidMove()){
      setTimeout(()=>alert('게임 오버! 이동 가능한 곳이 없어.'), 10);
    }
  }

  function tryMergeFrom(sr,sc){
    const v = grid[sr][sc].val;
    if(v==null) return false;
    // 동일 값 연결 컴포넌트 찾기
    const comp = [];
    const q=[[sr,sc]]; const seen = new Set([idx(sr,sc)]);
    while(q.length){
      const [r,c]=q.shift(); comp.push([r,c]);
      for(const [rr,cc] of neighbors4(r,c)){
        if(!seen.has(idx(rr,cc)) && grid[rr][cc].val===v) { seen.add(idx(rr,cc)); q.push([rr,cc]); }
      }
    }
    if(comp.length>=3){
      // 병합: 목적지에 합치고 나머지는 제거
      for(const [r,c] of comp){
        if(r===sr && c===sc) continue;
        grid[r][c].val = null;
      }
      grid[sr][sc].val = v*3;
      // 이펙트
      mergePulseAt(sr,sc);
      render();
      return true;
    }
    return false;
  }

  function advanceTurn(){
    turn++; turnEl.textContent = turn;
    toNextSpawn--; if(toNextSpawn<=0){
      spawnNewTiles(rand(4,5));
      toNextSpawn = 5;
    }
    spawnInEl.textContent = toNextSpawn;
  }

  function spawnNewTiles(n){
    const spots = emptyCells();
    if(spots.length===0) return;
    shuffle(spots);
    const count = Math.min(n, spots.length);
    for(let i=0;i<count;i++){
      const [r,c]=spots[i];
      grid[r][c].val = pickStartValue();
      spawnPopAt(r,c);
    }
    render();
  }

  function hasAnyValidMove(){
    for(let sr=0; sr<ROWS; sr++){
      for(let sc=0; sc<COLS; sc++){
        const v = grid[sr][sc].val;
        if(v==null) continue;
        // 가로선 검사
        for(let dc=0; dc<COLS; dc++){
          if(dc===sc) continue;
          if(grid[sr][dc].val==null && !grid[sr][dc].blocked){
            if(pathClear(sr,sc,sr,dc) && destNextToSame(sr,dc,v,sr,sc)) return true;
          }
        }
        // 세로선 검사
        for(let dr=0; dr<ROWS; dr++){
          if(dr===sr) continue;
          if(grid[dr][sc].val==null && !grid[dr][sc].blocked){
            if(pathClear(sr,sc,dr,sc) && destNextToSame(dr,sc,v,sr,sc)) return true;
          }
        }
      }
    }
    return false;
  }

  function updateHUD(){
    turnEl.textContent = turn;
    spawnInEl.textContent = toNextSpawn;
  }

  /* ---------- FX ---------- */
  function spawnPopAt(r,c){
    // 렌더 전/후 모두 호출될 수 있어 안전하게 DOM 찾아서 pop 클래스 부여
    requestAnimationFrame(()=>{
      const tile = findTileEl(r,c);
      if(tile){ tile.classList.remove('pop'); void tile.offsetWidth; tile.classList.add('pop'); }
    });
  }
  function mergePulseAt(r,c){
    requestAnimationFrame(()=>{
      const tile = findTileEl(r,c);
      if(tile){ tile.classList.remove('merge'); void tile.offsetWidth; tile.classList.add('merge'); }
    });
  }
  function shakeAt(r,c){
    const tile = findCellEl(r,c);
    if(!tile) return;
    tile.style.transition='transform .08s';
    tile.style.transform='translateX(2px)';
    setTimeout(()=>{tile.style.transform='translateX(-2px)'},80);
    setTimeout(()=>{tile.style.transform='translateX(0)'},160);
  }
  function flashPath(sr,sc,dr,dc, ok){
    if(!(sr===dr||sc===dc)) return; // 직선만
    const {x:x1,y:y1} = centerOf([sr,sc]);
    const {x:x2,y:y2} = centerOf([dr,dc]);
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1); line.setAttribute('y1', y1);
    line.setAttribute('x2', x2); line.setAttribute('y2', y2);
    line.setAttribute('class','fadeLine');
    if(!ok) line.style.stroke = '#ff6b6b';
    FX.appendChild(line);
    setTimeout(()=> line.remove(), 2000);
  }
  function floatTokenAtMid(sr,sc,dr,dc, v){
    const {x:x1,y:y1} = centerOf([sr,sc]);
    const {x:x2,y:y2} = centerOf([dr,dc]);
    const midx = (x1+x2)/2, midy = (y1+y2)/2;
    const t = document.createElement('div');
    t.className='floatToken';
    t.style.left = midx+'px'; t.style.top = midy+'px';
    t.textContent = `→ ${v}`;
    document.getElementById('boardWrap').appendChild(t);
    setTimeout(()=> t.remove(), 2000);
  }
  function findTileEl(r,c){
    const cell = findCellEl(r,c);
    return cell ? cell.querySelector('.tile') : null;
  }
  function findCellEl(r,c){
    return BOARD.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  }

  /* ---------- 이벤트 ---------- */
  resetBtn.addEventListener('click', ()=>{ init(true); });

  /* ---------- 시작 ---------- */
  init(true);
})();
</script>
</body>
</html>
