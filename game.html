<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <title>í•©ì¹˜ë‹¤ ë³´ë‹ˆ ì‹ ì´ë˜ì—ˆë‹¤</title>
    <style>
        :root {
            --cols: 5;
            --rows: 7;
            --gap: 6px;
            --bg: #0b0f14;
            --fg: #e8f0ff;
            --muted: #7f8da3;
            --tile: #18202b;
            --blocked: #161922;
            --accent: #46d3ff;
            --ok: #67ff9a;
            --warn: #ffcc4d;
            --err: #ff6b6b;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent
        }

        html, body {
            height: 100%
        }

        body {
            margin: 0;
            background: url('images/bg.png') no-repeat center center fixed;
            background-size: contain; /* âœ… ë¹„ìœ¨ ìœ ì§€í•˜ë©´ì„œ ì „ì²´ê°€ ë‹¤ ë³´ì´ê²Œ */
            background-color: #000000; /* âœ… ë‚¨ëŠ” ì—¬ë°±ì€ ì´ ìƒ‰ìœ¼ë¡œ ì±„ì›€ */
            color: var(--fg);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            /* ğŸ”½ í•˜ë‹¨ í”Œë¡œíŒ…ë°” ë†’ì´ë§Œí¼ ì—¬ë°± í™•ë³´ (ê¸°ì¡´ body ì¤‘ë³µ ì œê±°ìš©) */
            padding-bottom: calc(72px + env(safe-area-inset-bottom, 0px));
        }

        header {
            width: 100%;
            max-width: 480px;
            padding: 4px 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            background: linear-gradient(180deg,rgba(11,15,20,0.95),rgba(11,15,20,0.6) 70%,transparent);
            backdrop-filter: blur(6px);
        }

        #title {
            display: none !important;
            // font-size: 20px;
            // line-height: 0.8;
            // font-weight: 700;
            // color: #fff;
            // text-align: center
        }

        .stat {
            display: flex;
            justify-content: space-between; /* ì¢Œ-ìš°ë¡œ ë¶„ë¦¬ */
            align-items: center;
            width: 100%;
            max-width: 480px;
            font-size: 13px;
            margin-top: 4px;
            flex-wrap: nowrap;
        }

        .idtag {
            position: relative;
            display: inline-block;
            max-width: 200px; /* âœ… ë„ˆë¹„ ì œí•œ (ì›í•˜ëŠ” ê°’ìœ¼ë¡œ ì¡°ì • ê°€ëŠ¥) */
            white-space: nowrap;
            overflow: hidden;
            vertical-align: middle;
            color: #faff8c;
            background: #121722;
            border: 3px solid #2a3443;
            border-radius: 8px;
            padding: 2px 6px;
        }

            /* ë‚´ë¶€ í…ìŠ¤íŠ¸ë¥¼ ë¶€ë“œëŸ½ê²Œ ì¢Œìš°ë¡œ íë¥´ê²Œ */
            .idtag span {
                display: inline-block;
                animation: idScroll 6s linear infinite; /* ì†ë„ ì¡°ì • ê°€ëŠ¥ */
            }

            /* hover ì‹œ ì¼ì‹œì •ì§€ (ì„ íƒì‚¬í•­) */
            .idtag:hover span {
                animation-play-state: paused;
            }

        /* ì‹¤ì œ ìŠ¤í¬ë¡¤ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes idScroll {
            0% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(-50%);
            }

            100% {
                transform: translateX(0);
            }
        }


        #boardWrap {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            width: 85vw;
            max-width: 480px;
            aspect-ratio: 5/7;
            display: grid;
            grid-template-columns: repeat(var(--cols), 1fr);
            grid-template-rows: repeat(var(--rows), 1fr);
            gap: var(--gap);
            position: relative;
            margin: 0 auto;
        }

        .cell {
            aspect-ratio: 1/1;
            background: transparent;
            border: 2px solid #fffec92a;
            border-radius: 14px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

            .cell.blocked {
                background: var(--blocked);
                background-image: repeating-linear-gradient(135deg, #1f2533 0 8px, #141925 8px 16px);
                border-color: #20283a;
            }

            /* ì´ë™ ê°€ëŠ¥ / ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸ */
            .cell.possible-move::after {
                content: "";
                position: absolute;
                inset: 0;
                background: url("images/move_1.png") center/contain no-repeat;
                z-index: 5;
                animation: movePulse 1.2s ease-in-out infinite;
            }

            .cell.path-highlight::after {
                content: "";
                position: absolute;
                inset: 0;
                background: url("images/move_2.png") center/contain no-repeat;
                z-index: 6;
                animation: moveGlow 0.8s ease-in-out infinite;
            }

        .tile {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            user-select: none;
            transition: transform .15s ease;
        }

            .tile.sel {
                border: 3px solid var(--accent);
                border-radius: 14px; /* ğŸ”¹ ì„ íƒ ì‹œ ë‘¥ê·¼ ëª¨ì„œë¦¬ ì¶”ê°€ */
                transform: scale(1.1);
                box-shadow: 0 0 15px var(--accent), 0 0 25px rgba(70,211,255,0.7);
                z-index: 10;
            }

            .tile.spawn {
                animation: pop .22s ease-out;
            }

            .tile.bump {
                animation: bump .18s ease-out;
            }

            .tile.merge {
                animation: merge .22s ease-in-out;
            }

            .tile.moving {
                z-index: 500;
                pointer-events: none;
                box-shadow: 0 4px 12px rgba(70, 211, 255, 0.6);
                transform: scale(1.1);
                border: 2px solid var(--accent);
            }

        @keyframes pop {
            from {
                transform: scale(0.6);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes bump {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.08);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes merge {
            0% {
                transform: scale(0.95);
            }

            50% {
                transform: scale(1.12);
            }

            100% {
                transform: scale(1);
            }
        }


        .btn {
            appearance: none;
            border: 1px solid #2a3443;
            background: #121722;
            color: var(--fg);
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform .05s ease-out,background .2s;
        }

            .btn:active {
                transform: scale(0.98)
            }

        .msg {
            position: absolute;
            top: 42%;
            left: 50%;
            transform: translate(-50%,-50%);
            background: rgba(17,26,40,0.8);
            border: 1px solid #223043;
            padding: 8px 14px; /* ê¸°ì¡´ 16px 24px â†’ ì¤„ì„ */
            border-radius: 10px;
            font-size: 14px; /* ê¸°ì¡´ 15px â†’ ì‚´ì§ ì¤„ì„ */
            font-weight: 700;
            color: #ffcc4d;
            opacity: 0;
            min-width: 260px; /* ê¸°ì¡´ 420px â†’ í¬ê²Œ ì¶•ì†Œ */
            max-width: 120vw;
            white-space: pre-line;
            transition: opacity .4s ease;
            z-index: 1000;
            pointer-events: none;
            line-height: 1.6; /* ê¸°ì¡´ 3 â†’ ì»´íŒ©íŠ¸í•˜ê²Œ */
            text-align: center;
            opacity: 0;
            transition: opacity 0.4s ease-in-out; /* â† ì •í™•íˆ ì´ ì†ë„ */
        }

        #toast {
            top: 39%;
        }

        #toast2 {
            top: 45%; /* ì•„ë˜ìª½ì— ì‚´ì§ ë„ì›Œì„œ ê²¹ì¹˜ì§€ ì•Šê²Œ */
        }



        .msg.show {
            opacity: 1
        }

        #startMsg.hide {
            display: none;
        }

        #resultPopup {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.65);
            z-index: 999;
            visibility: hidden;
            opacity: 0;
            transition: opacity .25s;
        }

            #resultPopup.show {
                visibility: visible;
                opacity: 1
            }

        #resultBox {
            background: #161c29;
            padding: 24px;
            border-radius: 16px;
            text-align: center;
            min-width: 360px;
            max-width: 96vw;
            box-shadow: 0 10px 28px rgba(0,0,0,0.6);
        }

            #resultBox h2 {
                margin: 0 0 8px;
                font-size: 20px;
            }

            #resultBox p {
                margin: 6px 0;
                font-size: 14px;
                color: var(--muted);
            }

        #rankHeader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        #rankings {
            margin-top: 10px;
            max-height: 320px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #2a3443;
            border-radius: 10px;
        }

        .rank-item {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 6px 10px;
            border-bottom: 1px solid #222a3b;
            font-size: 14px;
            gap: 10px;
        }

            .rank-item .left, .rank-item .right {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .rank-item .score {
                min-width: 60px;
                text-align: right;
            }

            .rank-item .btn {
                font-size: 12px;
                padding: 2px 6px;
                height: 22px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                position: relative;
                top: -6px;
            }

        .crown {
            font-size: 16px;
            line-height: 1
        }

        .top1 .crown {
            color: gold;
            filter: drop-shadow(0 0 6px rgba(255,215,0,.35))
        }

        .top2 .crown {
            color: silver;
            filter: drop-shadow(0 0 6px rgba(192,192,192,.3))
        }

        .top3 .crown {
            color: #cd7f32;
            filter: drop-shadow(0 0 6px rgba(205,127,50,.3))
        }

        #noMovesMsg {
            margin-top: 8px;
            font-size: 13px;
            color: var(--warn);
        }


        .icon-btn {
            width: 56px;
            height: 56px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #121722;
            border: 1px solid #2a3443;
            border-radius: 50%;
            cursor: pointer;
            transition: transform .06s ease, background .2s ease, box-shadow .2s ease;
            box-shadow: 0 6px 14px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.02);
        }

            .icon-btn:active {
                transform: scale(0.97);
            }

            .icon-btn svg {
                width: 28px;
                height: 28px;
                fill: none;
                stroke: #cfe5ff;
                stroke-width: 2;
            }

            .icon-btn img.icon-img {
                width: 140%;
                height: 140%;
                object-fit: contain;
                pointer-events: none;
            }

        /* ë§ì¹˜ ë²„íŠ¼ì€ ëˆŒë¦´ ë•Œ ìŠ¤ì¼€ì¼ë§ ë¹„í™œì„±í™” */
        #btnHammer:active {
            transform: none;
        }

        #btnHammer {
            position: relative;
        }
        /* ë°°ì§€ ìœ„ì¹˜ ê¸°ì¤€ ê³ ì • */

        /* ê¸°ì¡´ pointer-events ê´€ê³„ë¥¼ ë‹¨ìˆœí™”: ë¶€ëª¨ë„ í´ë¦­ ê°€ëŠ¥ */
        #footerBar {
            position: static; /* âœ… fixed â†’ static ìœ¼ë¡œ ë³€ê²½ */
            transform: none; /* âœ… translateX ì œê±° */
            margin-top: 16px; /* ğŸ”¹ ë³´ë“œì™€ ê°„ê²© */
            width: 100%;
            max-width: 480px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px 0;
        }

        /* ë„¤ëª¨ ë°•ìŠ¤ ëŠë‚Œ ë¹¼ê³ , ë‹¨ìˆœ ì»¨í…Œì´ë„ˆë¡œ */
        .footer-glass {
            display: flex; /* ğŸ”‘ grid â†’ flex */
            gap: 150px; /* â† ì•„ì´ì½˜ ì‚¬ì´ ê±°ë¦¬ */
            background: transparent; /* ë„¤ëª¨ ë°•ìŠ¤ ì œê±° */
            border: 0;
            backdrop-filter: none;
            border-radius: 0;
            pointer-events: auto; /* ìì‹ë„ í´ë¦­ í—ˆìš© */
        }



        /* ==== ì„¤ì • íŒì—… ==== */
        #settingsPopup {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.55);
            z-index: 2000;
        }

            #settingsPopup.show {
                display: flex;
            }

        .settings-box {
            width: min(420px, 92vw);
            background: radial-gradient(120% 140% at 50% 0%, #1a2333 0%, #121827 60%, #101523 100%);
            border: 1px solid rgba(70, 211, 255, 0.15);
            border-radius: 16px;
            padding: 18px 14px;
            box-shadow: 0 18px 36px rgba(0,0,0,0.55), inset 0 0 0 1px rgba(255,255,255,0.03);
        }

        .settings-title {
            margin: 0 0 8px;
            padding: 0 8px;
            font-size: 16px;
            font-weight: 800;
            color: #e9f2ff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .settings-title .gear-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: var(--accent);
                box-shadow: 0 0 10px var(--accent);
            }

        .menu-list {
            display: grid;
            gap: 8px;
            margin-top: 8px;
        }

        .menu-btn {
            width: 100%;
            text-align: left;
            background: #111828;
            border: 1px solid #253149;
            color: #dbe7ff;
            padding: 12px 14px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: transform .05s ease, background .2s ease, border-color .2s ease;
        }

            .menu-btn:active {
                transform: translateY(1px);
            }

            .menu-btn .sub {
                display: block;
                font-size: 11px;
                color: #8ba1be;
                margin-top: 4px;
            }

        .settings-actions {
            display: flex;
            justify-content: center;
            margin-top: 12px;
        }

        #btnSettingsClose {
            min-width: 120px;
        }
        /* ==== ğŸª“ ë§ì¹˜ ì•„ì´í…œ ê´€ë ¨ ìŠ¤íƒ€ì¼ ==== */
        /* ğŸ”¨ ë§ì¹˜ ë§í’ì„  */
        .hammer-bubble {
            position: fixed;
            padding: 8px 10px;
            font-size: 12px;
            background: rgba(17,26,40,0.95);
            color: #e9f2ff;
            border: 1px solid rgba(70,211,255,0.25);
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.45);
            pointer-events: none;
            z-index: 4000;
            transform: translate(-50%, -8px);
            white-space: nowrap;
        }

        .hammer-icon {
            position: absolute;
            top: 1px;
            right: 1px;
            width: 40px;
            height: 40px;
            pointer-events: none;
        }

        .hammer-count {
            position: absolute;
            top: -6px;
            right: -6px;
            font-size: 11px;
            color: #fff;
            background: #ff4d4d;
            border: 2px solid #fff;
            border-radius: 999px;
            padding: 1px 6px;
            min-width: 20px;
            text-align: center;
            line-height: 1.2;
            box-shadow: 0 0 6px rgba(0,0,0,0.4);
        }



        body.hammer-select #board .cell:not(:has(.rock-block)) {
            filter: brightness(0.2);
            pointer-events: none;
        }
        /* ==== rock ìƒì„± ì• ë‹ˆë©”ì´ì…˜ ==== */
        @keyframes rockSpawn {
            0% {
                transform: scale(1);
            }

            30% {
                transform: scale(1.2);
            }
            /* 120% */
            50% {
                transform: scale(0.9);
            }
            /* 90% */
            100% {
                transform: scale(1);
            }
        }
        /* ==== ğŸ›‘ ì  ê³µê²© ê²½ê³  ì˜¤ë²„ë ˆì´ ==== */
        .warning-overlay {
            position: absolute;
            inset: 0;
            background-image: url('images/warning.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            animation: warningBlink 1s ease-in-out infinite;
            opacity: 0.5;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes warningBlink {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }

        .rock-block.spawn {
            animation: rockSpawn 0.3s ease-out forwards;
            transform-origin: center;
        }

        .bomb-effect {
            animation: bombFade 0.6s ease-out forwards;
        }


        /* ==== ì¸ê²Œì„ ì§„ì… í˜ì´ë“œ ==== */
        #fadeLayer {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 9999;
            opacity: 1;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }

            #fadeLayer.fade-in {
                opacity: 0;
            }
        .footer-center {
            display: none;
        }

    </style>
</head>
<body>
    <header>
        <div class="stat">
            <span class="idtag" id="idView"><span>ID: -</span></span>
            <div class="stat-right">
                <span class="stat-turn">í„´: <b id="turn">0</b></span>
                <span class="stat-next">ë‹¤ìŒ ì†Œí™˜: <b id="nextSpawn">3</b></span>
                <span class="stat-mega">ëŒ€ì†Œí™˜ ë‚¨ìŒ: <b id="megaLeft">5</b></span>
            </div>
        </div>
    </header>

    <div id="boardWrap">
        <div id="board"></div>
    </div>

    <div class="msg" id="toast"></div>
    <div class="msg" id="toast2"></div>
    <div class="msg show" id="startMsg">ëª¬ìŠ¤í„° íƒ­!</div>

    <div id="resultPopup">
        <div id="resultBox">
            <h2 id="popupTitle">ê²Œì„ ì˜¤ë²„</h2>
            <p id="finalScore"></p>
            <p id="noMovesMsg" style="display:none;">ì´ë™ ê°€ëŠ¥í•œ ì†Œí™˜ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
            <div id="rankHeader"><h3 style="margin:0;font-size:16px;">ë­í‚¹ TOP 100</h3></div>
            <div id="rankings"><div style="padding:10px">ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ì¤‘...</div></div>
            <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;">
                <button class="btn" id="btnRestart">ë‹¤ì‹œ ì‹œì‘</button>
                <button class="btn" id="btnBack">ëŒì•„ê°€ê¸°</button>
                <button class="btn" id="btnViewBest">ë‚´ ìµœê³  ê¸°ë¡ í™•ì¸</button>


            </div>
        </div>
    </div>
    <!-- ===== í•˜ë‹¨ í”Œë¡œíŒ…ë°” ===== -->
    <div id="footerBar">
        <div class="footer-glass">
            <!-- ì™¼ìª½: ë§ì¹˜ -->
            <button id="btnHammer" class="icon-btn" aria-label="ë§ì¹˜ ì•„ì´í…œ">
                <img src="images/hammer_big.png" alt="hammer" class="icon-img">
                <span id="hammerCount" class="hammer-count">0</span>
            </button>

            <!-- ê°€ìš´ë°: ë¯¸ë‹ˆ ìŠ¤íƒ¯ -->
            <div class="footer-center">
                í„´ <b id="turnMini">0</b> Â· ë‹¤ìŒ ì†Œí™˜ <b id="nextMini">3</b>
            </div>

            <!-- ì˜¤ë¥¸ìª½: ì„¤ì • -->
            <button id="btnSettings" class="icon-btn" aria-label="ì„¤ì •">
                <img src="images/setup.png" alt="setup" class="icon-img">
            </button>



        </div>
    </div>

    <!-- ===== ì„¤ì • íŒì—… ===== -->
    <div id="settingsPopup" role="dialog" aria-modal="true">
        <div class="settings-box">
            <h3 class="settings-title"><span class="gear-dot"></span> ì„¤ì •</h3>
            <div class="menu-list">
                <button class="menu-btn" id="mNew">
                    ìƒˆ ê²Œì„
                    <span class="sub">í˜„ì¬ ì§„í–‰ì¤‘ì¸ ë‚´ìš©ì„ ì´ˆê¸°í™”í•˜ê³  ìƒˆë¡œ ì‹œì‘</span>
                </button>
                <button class="menu-btn" id="mSave">
                    ê²Œì„ ì €ì¥ (ë¡œì»¬)
                    <span class="sub">ë¸Œë¼ìš°ì € ë¡œì»¬ ì €ì¥ì†Œì— í˜„ì¬ ë³´ë“œë¥¼ ì €ì¥</span>
                </button>
                <button class="menu-btn" id="mLoad">
                    ë¶ˆëŸ¬ì˜¤ê¸° (ë¡œì»¬)
                    <span class="sub">ì €ì¥í•œ ë³´ë“œë¥¼ 1íšŒ ë¶ˆëŸ¬ì˜´</span>
                </button>
                <button class="menu-btn" id="mViewBest">
                    ë‚´ ìµœê³  ê¸°ë¡ ë³´ê¸°
                    <span class="sub">ê°€ì¥ ë†’ì€ ì ìˆ˜ì˜ ë³´ë“œë¥¼ í™•ì¸</span>
                </button>
                <button class="menu-btn" id="mResetId">
                    ì•„ì´ë”” ì´ˆê¸°í™”
                    <span class="sub">í”Œë ˆì´ì–´ IDë¥¼ ë‹¤ì‹œ ì…ë ¥</span>
                </button>
                <button class="menu-btn" id="mRanking">
                    ë­í‚¹ ë¶ˆëŸ¬ì˜¤ê¸°
                    <span class="sub">ë­í‚¹ TOP 100ì„ í™•ì¸</span>
                </button>
                <button class="menu-btn" id="mExit">
                    ë‚˜ê°€ê¸°
                    <span class="sub">íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ ì´ë™</span>
                </button>
            </div>
            <div class="settings-actions">
                <button class="btn" id="btnSettingsClose">ë‹«ê¸°</button>
            </div>
        </div>
    </div>
    <script>
        (() => {

            const IMAGE_URLS = [
                "images/block-1.png", "images/block-2.png", "images/block-3.png",
                "images/block-4.png", "images/block-5.png", "images/block-6.png",
                "images/block-7.png", "images/block-8.png", "images/block-9.png",
                "images/blocked.png", "images/empty.png", "images/bg.png", "images/hammer.png",
                "images/hammer_big.png", "images/rock.png", "images/setup.png",
                "images/bomb01.png", "images/bomb02.png", "images/bomb03.png", "images/bomb04.png", "images/bomb05.png", "images/bomb06.png", "images/bomb07.png", "images/bomb08.png", "images/bomb09.png", "images/bomb10.png", "images/bomb11.png", "images/bomb12.png"

            ];

            /* ====== ì´ë¯¸ì§€ í”„ë¦¬ë¡œë“œ ====== */
            function preloadImages(urls) {
                return Promise.all(urls.map(src => new Promise(res => {
                    const img = new Image(); img.onload = res; img.onerror = res; img.src = src;
                })));
            }

            // âœ… ë¸”ë¡ ì´ë¯¸ì§€ ë””ì½”ë”©ê¹Œì§€ ë¯¸ë¦¬ ì™„ë£Œ
            async function decodeAllBlockImages() {
                const urls = [
                    "images/block-1.png", "images/block-2.png", "images/block-3.png",
                    "images/block-4.png", "images/block-5.png", "images/block-6.png",
                    "images/block-7.png", "images/block-8.png", "images/block-9.png"
                ];
                await Promise.all(urls.map(src => {
                    const img = new Image();
                    img.src = src;
                    return img.decode().catch(() => { });
                }));
                console.log("âœ… ë¸”ë¡ ì´ë¯¸ì§€ decode ì™„ë£Œ");
            }


            /* ====== ğŸµ ì‚¬ìš´ë“œ ë¡œë“œ ====== */
            window.sounds = {
                bgm: new Audio("sounds/bgm.mp3"),
                move: new Audio("sounds/move.mp3"),
                click: new Audio("sounds/click.mp3"),
                toast: new Audio("sounds/toast.mp3"),
                gameover: new Audio("sounds/gameover.mp3"),
                mergeMove: new Audio("sounds/move.mp3"),
                attack: new Audio("sounds/attack.mp3"),
                hammer: new Audio("sounds/hammer.mp3"),
                clickMenu: new Audio("sounds/click_menu.mp3"),
                warning: new Audio("sounds/warning.mp3"),
                bigcall: new Audio("sounds/bigcall.mp3"),
                blocks: {
                    3: new Audio("sounds/block-2.mp3"),
                    9: new Audio("sounds/block-3.mp3"),
                    27: new Audio("sounds/block-4.mp3"),
                    81: new Audio("sounds/block-5.mp3"),
                    243: new Audio("sounds/block-6.mp3"),
                    729: new Audio("sounds/block-7.mp3"),
                    2187: new Audio("sounds/block-8.mp3"),
                    6561: new Audio("sounds/block-9.mp3")
                }
            };
            sounds.bgm.loop = true;
            sounds.bgm.volume = 1;
            sounds.move.volume = 1;
            sounds.mergeMove.volume = 1;
            sounds.click.volume = 0.5;
            sounds.toast.volume = 1;
            sounds.gameover.volume = 1;
            sounds.attack.volume = 1;
            sounds.warning.volume = 1;
            sounds.bigcall.volume = 1;
            sounds.hammer.volume = 1;
            sounds.clickMenu.volume = 0.6;

            for (let k in sounds.blocks) sounds.blocks[k].volume = 1;

            /* ====== ê¸°ë³¸ ì„¤ì •/ìƒìˆ˜ ====== */
            const GAS_URL = "https://script.google.com/macros/s/AKfycbwIJmiCseB5UAQjfTIKN_812VkvXdLqmTObnq01JGxJV6D3T5TzKdsrU26_qbxQGGPq/exec";
            const COLS = 5, ROWS = 7;
            const INIT_TILES = 12;
            const SPAWN_EVERY = 3;
            const SPAWN_BATCH = 3;
            const MEGA_INTERVAL = 5;
            // ==== âš”ï¸ ì ì˜ ê³µê²© í™•ë¥  ì„¤ì • ====
            const ENEMY_ATTACK_CHANCE = 0.3; // 0.0~1.0 ì‚¬ì´ (ê³µê²© ì˜ˆê³  í™•ë¥ )
            let gameActive = false; // ê²Œì„ í™œì„± ìƒíƒœ ì—¬ë¶€


            // ì´ë™/ë¨¸ì§€ ì†ë„
            const MOVE_SPEED = 80;    // ì¼ë°˜ ì´ë™
            const MERGE_SPEED = 120;  // ê·¸ë£¹ í¡ìˆ˜ ì´ë™

            // ë”œë ˆì´ ìƒìˆ˜
            const MERGE_CHAIN_DELAY = 200;   // ì—°ì† ë¨¸ì§€ ê°„ ê°„ê²©
            const SPAWN_TO_MERGE_DELAY = 200; // ìŠ¤í° í›„ ìë™ ë¨¸ì§€ ì „ ëŒ€ê¸°

            const sleep = (ms) => new Promise(res => setTimeout(res, ms));

            const TILE_IMAGES = {
                1: "images/block-1.png", 3: "images/block-2.png", 9: "images/block-3.png",
                27: "images/block-4.png", 81: "images/block-5.png", 243: "images/block-6.png",
                729: "images/block-7.png", 2187: "images/block-8.png", 6561: "images/block-9.png"
            };

            let grid = [], turn = 0, untilSpawn = SPAWN_EVERY, spawnCount = 0, selected = null, history = [], gameOverShown = false;
            let lastGameState = null, bestScore = 0, bestGameState = null;
            let isAnimating = false;
            // ğŸª¨ rock ë¸”ë¡ ìœ„ì¹˜ ì¶”ì ìš© Set
            const rockSet = new Set();

            const board = document.getElementById('board');
            let hammerMode = false;
            let hammerCount = 0;
            function updateHammerUI() {
                document.getElementById("hammerCount").textContent = hammerCount;
            }

            const elTurn = document.getElementById('turn'),
                elNext = document.getElementById('nextSpawn'),
                elMega = document.getElementById('megaLeft');
            const elTurnMini = document.getElementById('turnMini');
            const elNextMini = document.getElementById('nextMini');

            const toast = document.getElementById('toast');
            let toastTimer = null;
            // === ğŸ¯ í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ë²„í¼ ì‹œìŠ¤í…œ (í•œ í„´ ë‚´ ë¬¶ì–´ì„œ í‘œì‹œ) ===
            let toastBuffer = [];

            // ë©”ì‹œì§€ë¥¼ íì— ì„ì‹œ ì €ì¥
            function queueInfo(msg, type = "info") {
                toastBuffer.push({ msg, type });
            }

            // ë²„í¼ì— ìŒ“ì¸ ë©”ì‹œì§€ë¥¼ í•œ ë²ˆì— ì¶œë ¥
            function flushToast() {
                // ğŸ¯ ê²Œì„ ì˜¤ë²„ ìƒíƒœë©´ í† ìŠ¤íŠ¸ í‘œì‹œ ì™„ì „ ì°¨ë‹¨
                if (gameOverShown || !gameActive) {
                    toastBuffer = []; // ë²„í¼ë„ ë¹„ì›Œì„œ ì´í›„ ëˆ„ì  ë°©ì§€
                    return;
                }
                if (toastBuffer.length === 0) return;

                const grouped = {};
                for (const t of toastBuffer) {
                    if (!grouped[t.type]) grouped[t.type] = [];
                    grouped[t.type].push(t.msg);
                }

                // ë¶ˆí•„ìš”í•œ 'ì˜¤ë¥˜/ê²½ê³ /ì„±ê³µ' í—¤ë” ì œê±°
                let mergedText = "";
                if (grouped.ok) mergedText += grouped.ok.join("\n") + "\n";
                if (grouped.warn) mergedText += grouped.warn.join("\n") + "\n";
                if (grouped.err) mergedText += grouped.err.join("\n") + "\n";
                if (grouped.info) mergedText += grouped.info.join("\n");

                // ë§ˆì§€ë§‰ ë©”ì‹œì§€ íƒ€ì… ê¸°ì¤€ìœ¼ë¡œ ìƒ‰ìƒ ì ìš©
                const lastType = Object.keys(grouped).pop() || "ok";
                info(mergedText.trim(), lastType);

                toastBuffer = [];
            }



            function info(t, k) {
                // âœ… í† ìŠ¤íŠ¸ ë‘ ê°œ ë‹¤ ì°¾ê¸°
                const toast1 = document.getElementById('toast');
                const toast2 = document.getElementById('toast2');

                // ì–´ë–¤ í† ìŠ¤íŠ¸ë¥¼ ì“¸ì§€ ê²°ì •
                const active1 = toast1.classList.contains('show');
                const target = active1 ? toast2 : toast1;

                target.textContent = t;
                target.style.color = k === 'err' ? 'var(--err)' :
                    k === 'warn' ? 'var(--warn)' :
                        k === 'ok' ? 'var(--ok)' : 'var(--fg)';
                target.classList.remove('show'); void target.offsetWidth; target.classList.add('show');

                // ê¸°ì¡´ íƒ€ì´ë¨¸ ì œê±° ë° ìƒˆ íƒ€ì´ë¨¸ ë“±ë¡
                const DISPLAY_TIME = 3500;
                clearTimeout(target._timer);
                target._timer = setTimeout(() => {
                    target.classList.remove('show');
                }, DISPLAY_TIME);

                // ğŸ”Š ì‚¬ìš´ë“œ (ê¸°ì¡´ì²˜ëŸ¼ ìœ ì§€)
                try {
                    sounds.toast.currentTime = 0;
                    sounds.toast.play().catch(() => { });
                } catch (e) { }
            }


            const popup = document.getElementById('resultPopup'),
                finalScore = document.getElementById('finalScore'),
                popupTitle = document.getElementById('popupTitle');
            const idView = document.getElementById('idView');
            const rankingsEl = document.getElementById('rankings');
            const noMovesMsg = document.getElementById('noMovesMsg');

            /* ====== ì•„ì´ë”” ====== */
            let playerId = localStorage.getItem("mergePlayerId");
            function askPlayerId(force = false) {
                if (!playerId || force) {
                    let input = "";
                    while (!input) {
                        input = prompt("í”Œë ˆì´ì–´ ì•„ì´ë””ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
                        if (input === null) { input = ""; }
                    }
                    playerId = input.trim();
                    localStorage.setItem("mergePlayerId", playerId);
                    info(`ì•„ì´ë”” ì„¤ì •ë¨: ${playerId}`);
                }
                idView.textContent = "ID: " + playerId;
            }

            /* ====== ìœ í‹¸ ====== */
            const key = (r, c) => `${r},${c}`;
            const cloneGrid = (g) => g.map(r => r.slice());
            const inBounds = (r, c) => r >= 0 && r < ROWS && c >= 0 && c < COLS;
            const isEmpty = (r, c) => grid[r][c] === 0;
            const isBlocked = (r, c) => grid[r][c] === -1;
            const isTile = (r, c) => grid[r][c] > 0;
            function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]]; } }
            function listEmpty() {
                const out = [];
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const k = `${r},${c}`;
                        if (grid[r][c] === 0 && !rockSet.has(k)) {
                            out.push({ r, c });
                        }
                    }
                }
                return out;
            }

            // âœ… createRockAt()ëŠ” listEmpty() ë°–ìœ¼ë¡œ ì´ë™!
            function createRockAt(r, c) {
                const cell = board.children[r * COLS + c];
                if (!cell || cell.querySelector('.rock-block')) return;
                const rock = document.createElement('div');
                rock.className = 'tile rock-block';
                rock.style.backgroundImage = "url('images/rock.png')";
                rock.style.position = 'absolute';
                rock.style.inset = '0';
                rock.style.pointerEvents = 'auto';
                cell.appendChild(rock);


                // ğŸ’¥ rock ìƒì„± ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì¶”ê°€
                rock.classList.add('spawn');
                // âš ï¸ ê²½ê³  ì˜¤ë²„ë ˆì´ ì¶”ê°€
                const overlay = document.createElement('div');
                overlay.className = 'warning-overlay';
                rock.appendChild(overlay);


                rockSet.add(`${r},${c}`);

                // ğŸ”Š ê³µê²© ì‚¬ìš´ë“œ ì¶”ê°€
                try {
                    sounds.attack.currentTime = 0;
                    sounds.attack.play().catch(() => { });
                } catch (e) { console.error(e); }
            }

            // ğŸ’¥ rock ì œê±° ì‹œ í­ë°œ ìŠ¤í”„ë¼ì´íŠ¸ ì¬ìƒ
            // ğŸ’¥ rock ì œê±° ì‹œ í­ë°œ ìŠ¤í”„ë¼ì´íŠ¸ ì¬ìƒ (ê¹œë¹¡ì„ ë°©ì§€ ë²„ì „)
            function playBombAnimation(r, c, options = {}) {
                const { frameCount = 12, fps = 24, scale = 1.0 } = options;
                const cell = board.children[r * COLS + c];
                if (!cell) return;

                const bomb = document.createElement('div');
                bomb.className = 'tile bomb-effect';
                bomb.style.position = 'absolute';
                bomb.style.inset = '0';
                bomb.style.backgroundSize = 'contain';
                bomb.style.backgroundRepeat = 'no-repeat';
                bomb.style.backgroundPosition = 'center';
                bomb.style.transform = `scale(${scale})`;
                bomb.style.zIndex = 9999;
                cell.appendChild(bomb);

                // âœ… ëª¨ë“  í­ë°œ í”„ë ˆì„ ë¯¸ë¦¬ ë¡œë“œ í›„ ì‹¤í–‰
                const frames = Array.from({ length: frameCount }, (_, i) => `images/bomb${String(i + 1).padStart(2, '0')}.png`);
                const preloadAll = frames.map(src => new Promise(res => {
                    const img = new Image();
                    img.onload = res;
                    img.onerror = res;
                    img.src = src;
                }));

                Promise.all(preloadAll).then(() => {
                    let frame = 1;
                    const interval = 1000 / fps;
                    const timer = setInterval(() => {
                        bomb.style.backgroundImage = `url('images/bomb${String(frame).padStart(2, '0')}.png')`;
                        frame++;
                        if (frame > frameCount) {
                            clearInterval(timer);
                            bomb.remove();
                        }
                    }, interval);
                });
            }


            function randomValue() { return [1, 1, 1, 1, 3, 3, 9][(Math.random() * 7) | 0]; }

            /* ê¹œë¹¡ì„ ë°©ì§€ í”Œë ˆì´ìŠ¤í™€ë” */
            function addEmptyPlaceholderAt(r, c) {
                const cell = board.children[r * COLS + c]; if (!cell) return;
                if (cell.querySelector('.placeholder')) return;
                const ph = document.createElement('div');
                ph.className = 'tile placeholder';
                ph.style.backgroundImage = "url('images/empty.png')";
                cell.appendChild(ph);
            }
            function removePlaceholderAt(r, c) {
                const cell = board.children[r * COLS + c]; if (!cell) return;
                const ph = cell.querySelector('.placeholder'); if (ph) ph.remove();
            }

            /* ====== ë Œë” ì ê¸ˆ ====== */
            const renderLocks = new Set();
            const lockCell = (r, c) => renderLocks.add(`${r},${c}`);
            const unlockCell = (r, c) => renderLocks.delete(`${r},${c}`);
            const isLocked = (r, c) => renderLocks.has(`${r},${c}`);

            /* ====== ì…€ ë Œë” ====== */
            function drawCell(r, c, opt = {}) {
                if (!opt.force && isLocked(r, c)) return;
                const idx = r * COLS + c, cell = board.children[idx];
                cell.classList.toggle('blocked', isBlocked(r, c));
                const tiles = cell.querySelectorAll('.tile:not(.placeholder)'); tiles.forEach(n => n.remove());
                const v = grid[r][c];
                if (v > 0) {
                    if (v > 0) {
                        const t = document.createElement('div');
                        t.className = 'tile';
                        t.dataset.val = v;
                        if (opt.spawn) t.classList.add('spawn');
                        if (TILE_IMAGES[v]) t.style.backgroundImage = `url(${TILE_IMAGES[v]})`;
                        cell.appendChild(t);

                        // âœ… ë§ì¹˜ëŠ” 'ìŠ¤í°ëœ ë¸”ë¡'ì¼ ë•Œë§Œ í™•ë¥ ì ìœ¼ë¡œ ë¶€ì°©, ë§ì¹˜ ì•„ì´í…œ ë“±ì¥ í™•ë¥ 
                        if (opt.spawn && Math.random() < 0.1) {
                            t.dataset.hammer = "1";
                            const icon = document.createElement('img');
                            icon.src = "images/hammer.png";
                            icon.className = "hammer-icon";
                            t.appendChild(icon);
                        }
                    }


                } else if (v === -1) {
                    const b = document.createElement('div');
                    b.className = 'tile';
                    b.style.backgroundImage = "url('images/blocked.png')";
                    cell.appendChild(b);
                } else if (v === -2) {
                    const b = document.createElement('div');
                    b.className = 'tile';
                    b.style.backgroundImage = "url('images/rock.png')";
                    cell.appendChild(b);
                } else {

                    const e = document.createElement('div'); e.className = 'tile'; e.style.backgroundImage = "url('images/empty.png')";
                    cell.appendChild(e);
                }
            }

            function updateMegaLeft() {
                const batchesSinceLastMega = spawnCount % MEGA_INTERVAL;
                const remBatches = (MEGA_INTERVAL - batchesSinceLastMega) || MEGA_INTERVAL;
                const movesLeft = (remBatches - 1) * SPAWN_EVERY + untilSpawn;
                elMega.textContent = String(movesLeft);
            }
            let hammerBubbleEl = null;
            function ensureHammerBubble() {
                return null; // âš¡ ì•„ì˜ˆ ìƒì„±í•˜ì§€ ì•ŠìŒ
                if (hammerBubbleEl) return hammerBubbleEl;
                hammerBubbleEl = document.createElement('div');
                hammerBubbleEl.className = 'hammer-bubble';
                hammerBubbleEl.textContent = 'ë°©í•´ ë¸”ë¡ì„ íƒ­í•´ì„œ ì œê±°';
                hammerBubbleEl.style.display = 'none';
                document.body.appendChild(hammerBubbleEl);
                return hammerBubbleEl;
            }
            function positionHammerBubble() {
                const b = ensureHammerBubble();
                const btn = document.getElementById('btnHammer');
                if (!btn || b.style.display === 'none') return;
                const r = btn.getBoundingClientRect();
                b.style.left = (r.left + r.width / 2) + 'px';
                b.style.top = (r.top - 10) + 'px';
            }
            function showHammerBubble() {
                const b = ensureHammerBubble();
                b.style.display = 'block';
                positionHammerBubble();
            }

            function showHammerBubbleAt(x, y) {
                const b = ensureHammerBubble();
                b.style.display = 'block';
                b.style.left = `${x}px`;
                b.style.top = `${y}px`;
            }

            function hideHammerBubble() {
                const bubble = document.querySelector('.hammer-bubble');
                if (bubble) bubble.style.display = 'none';
            }

            window.addEventListener('resize', positionHammerBubble);
            window.addEventListener('scroll', positionHammerBubble, true);

            function renderAll(spawn = false) {
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) drawCell(r, c, { spawn: spawn && isTile(r, c) });
                elTurn.textContent = String(turn);
                elNext.textContent = String(untilSpawn);
                elTurnMini.textContent = String(turn);
                elNextMini.textContent = String(untilSpawn);
                updateMegaLeft();
            }

            function highlightSelection() {
                for (const cell of board.children) { const t = cell.querySelector('.tile'); if (t) t.classList.remove('sel'); }
                if (selected) { const tile = board.children[selected.r * COLS + selected.c].querySelector('.tile'); if (tile) tile.classList.add('sel'); }
            }

            /* ====== ì´ë™ ê°€ëŠ¥ ìœ„ì¹˜ í‘œì‹œ ====== */
            function clearPossibleMoves() {
                board.querySelectorAll('.possible-move').forEach(el => el.classList.remove('possible-move'));
                board.querySelectorAll('.path-highlight').forEach(el => el.classList.remove('path-highlight'));
            }
            function showPossibleMoves(r, c) {
                const val = grid[r][c];
                const currentGroup = floodSame(r, c, val);
                for (let tr = 0; tr < ROWS; tr++) {
                    for (let tc = 0; tc < COLS; tc++) {
                        if (!isEmpty(tr, tc)) continue;
                        const to = { r: tr, c: tc };
                        const path = findPathViaEmpties({ r, c }, to); if (!path) continue;
                        const gsize = groupSizeIfMoved({ r, c }, to, val); if (gsize < 2) continue;
                        if (currentGroup.length === 2 && gsize < 3) continue;
                        board.children[tr * COLS + tc].classList.add('possible-move');
                    }
                }
            }

            /* ====== ì´ˆê¸°í™” ====== */
            function init() {
                function updateLoadIcon() {
                    const btn = document.getElementById('mLoad');
                    const hasSave = !!localStorage.getItem("mergeSave");

                    // ê¸°ì¡´ ì•„ì´ì½˜ ì œê±°
                    const old = btn.querySelector('.save-icon');
                    if (old) old.remove();

                    // ì €ì¥ ìˆìœ¼ë©´ ìƒˆë¡œ ì¶”ê°€
                    if (hasSave) {
                        const icon = document.createElement('span');
                        icon.className = 'save-icon';
                        icon.textContent = 'ğŸ“‚';
                        icon.style.marginLeft = '4px';
                        icon.style.display = 'inline-block';
                        icon.style.verticalAlign = 'middle';

                        // âœ… ë²„íŠ¼ í…ìŠ¤íŠ¸ ë°”ë¡œ ì˜†ì— ë¶™ì´ê¸°
                        const textNode = [...btn.childNodes].find(n => n.nodeType === 3); // ìˆœìˆ˜ í…ìŠ¤íŠ¸ ë…¸ë“œ ì°¾ê¸°
                        if (textNode) {
                            textNode.after(icon);
                        } else {
                            btn.appendChild(icon); // fallback
                        }
                    }
                }



                askPlayerId();

                const savedBest = Number(localStorage.getItem("mergeBestScore") || 0);
                if (!Number.isNaN(savedBest)) bestScore = savedBest;
                try { const savedState = localStorage.getItem("mergeBestState"); if (savedState) bestGameState = JSON.parse(savedState); } catch (e) { }

                board.innerHTML = '';
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell'; cell.dataset.r = r; cell.dataset.c = c;
                        cell.addEventListener('click', onTapCell);
                        board.appendChild(cell);
                    }
                }
                newGame();

                document.getElementById('btnRestart').addEventListener('click', () => {
                    popup.classList.remove('show');
                    window.location.reload(); // ğŸ”„ ì™„ì „ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ì¬ì‹œì‘
                });

                document.getElementById('btnBack').addEventListener('click', () => { popup.classList.remove('show'); });
                document.getElementById('btnViewBest').addEventListener('click', () => {
                    if (bestGameState) { renderMiniPopup(bestGameState, playerId, bestScore); }
                    else alert("ì•„ì§ ìµœê³  ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.");
                });

                // ===== í•˜ë‹¨ ì•„ì´ì½˜ / ì„¤ì • íŒì—… =====
                const settingsPopup = document.getElementById('settingsPopup');
                const openSettings = () => settingsPopup.classList.add('show');
                const closeSettings = () => settingsPopup.classList.remove('show');
                function setHammerMode(on) {
                    hammerMode = !!on;
                    if (hammerMode) {
                        document.body.classList.add('hammer-select');
                        showHammerBubble();
                    } else {
                        document.body.classList.remove('hammer-select');
                        hideHammerBubble();
                    }
                }

                const btnHammer = document.getElementById('btnHammer');
                btnHammer.addEventListener('click', (e) => {
                    e.stopPropagation();
                    try { sounds.clickMenu.currentTime = 0; sounds.clickMenu.play().catch(() => { }); } catch (e) { }

                    if (isAnimating) return;

                    // âœ… ë§ì¹˜ ê°œìˆ˜ í™•ì¸
                    if (hammerCount <= 0) {
                        info("ì‚¬ìš©í•  ë§ì¹˜ê°€ ì—†ìŠµë‹ˆë‹¤.", "warn");
                        return;
                    }

                    // âœ… rock ë¸”ëŸ­ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
                    const hasRock = board.querySelector('.rock-block');
                    if (!hasRock) {
                        info("ì œê±°í•  ë¸”ëŸ­ì´ ì—†ìŠµë‹ˆë‹¤.", "warn");
                        return; // ğŸ”¥ ë”¤ë“œ ì§„ì… X
                    }

                    // âœ… ì •ìƒì ì¸ ê²½ìš°ì—ë§Œ ëª¨ë“œ ì§„ì…
                    if (hammerMode) {
                        setHammerMode(false);
                    } else {
                        setHammerMode(true);
                        const r = btnHammer.getBoundingClientRect();
                        const centerX = r.left + r.width / 2;
                        const topY = r.top - 10;
                        showHammerBubbleAt(centerX, topY);
                    }
                });
                // ==== ğŸ›  ë§ì¹˜ ì•„ì´í…œ ì‚¬ìš© ====
                board.addEventListener('click', (e) => {
                    if (!hammerMode) return;
                    const cell = e.target.closest('.cell');
                    if (!cell) return;

                    const rock = cell.querySelector('.rock-block');
                    if (rock) {
                        // âš ï¸ warning-overlayë„ í•¨ê»˜ ì œê±°
                        const overlay = rock.querySelector('.warning-overlay');
                        if (overlay) overlay.remove();

                        // âœ… ë°©í•´ë¸”ë¡ ì œê±°
                        rock.remove();
                        const r = +cell.dataset.r;
                        const c = +cell.dataset.c;
                        rockSet.delete(`${r},${c}`);

                        // ğŸ’¥ í­ë°œ ìŠ¤í”„ë¼ì´íŠ¸ ì¬ìƒ
                        playBombAnimation(r, c, { fps: 30, scale: 2 });


                        // âœ… ğŸ”Š ë§ì¹˜ ì‚¬ìš´ë“œ ì¬ìƒ
                        try {
                            sounds.hammer.currentTime = 0;
                            sounds.hammer.play().catch(() => { });
                        } catch (e) { console.error(e); }

                        // âœ… ë§ì¹˜ ì°¨ê°
                        hammerCount = Math.max(0, hammerCount - 1);
                        updateHammerUI();

                        // âœ… ëª¨ë“œ í•´ì œ (ë”¤ë“œ í•´ì œ í¬í•¨)
                        hammerMode = false;
                        document.body.classList.remove('hammer-select');
                        hideHammerBubble();

                        info("ë°©í•´ ë¸”ë¡ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤!", "ok");
                    } else {
                        // âœ… ë°©í•´ë¸”ë¡ì´ í•˜ë‚˜ë„ ì—†ì„ ê²½ìš°: ë”¤ë“œ ìœ ì§€, í† ìŠ¤íŠ¸ë§Œ ì¶œë ¥
                        const hasAnyRock = board.querySelector('.rock-block');
                        if (!hasAnyRock) {
                            info("ì œê±°í•  ë¸”ëŸ­ì´ ì—†ìŠµë‹ˆë‹¤.", "warn");
                            return; // ğŸ”¥ ëª¨ë“œ ìœ ì§€
                        }

                        // âœ… ì˜ëª»ëœ ìœ„ì¹˜ í´ë¦­: í† ìŠ¤íŠ¸ë§Œ ë„ìš°ê³  ëª¨ë“œ ì¢…ë£Œ
                        info("ë°©í•´ ë¸”ë¡ë§Œ ì œê±°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!", "warn");
                        hammerMode = false;
                        document.body.classList.remove('hammer-select');
                        hideHammerBubble();
                    }
                });



                document.getElementById('btnSettings').addEventListener('click', () => {
                    try { sounds.clickMenu.currentTime = 0; sounds.clickMenu.play().catch(() => { }); } catch (e) { }
                    openSettings();
                });

                document.getElementById('btnSettingsClose').addEventListener('click', closeSettings);
                settingsPopup.addEventListener('click', (e) => { if (e.target.id === 'settingsPopup') closeSettings(); });

                // ë©”ë‰´ í´ë¦­
                document.getElementById('mNew').addEventListener('click', () => {
                    closeSettings();
                    // ğŸ”„ ì™„ì „ ì´ˆê¸°í™”: ìƒˆë¡œê³ ì¹¨
                    window.location.reload();
                });

                document.getElementById('mSave').addEventListener('click', () => {
                    const ok = saveGameToLocal();
                    if (ok) {
                        info("ğŸ’¾ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.", "ok");
                        sounds.toast.currentTime = 0;
                        sounds.toast.play().catch(() => { });
                        document.getElementById('settingsPopup').classList.remove('show');
                        updateLoadIcon(); // âœ… ì €ì¥ í›„ ì•„ì´ì½˜ ê°±ì‹ 
                    } else {
                        info("ì €ì¥ ì‹¤íŒ¨", "err");
                    }
                });



                document.getElementById('mLoad').addEventListener('click', () => {
                    const ok = loadGameFromLocal();
                    if (ok) {
                        renderAll(true);
                        info("ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!");
                        checkGameOverSoon();
                    }

                    else info("ë¶ˆëŸ¬ì˜¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", "warn");
                    closeSettings();
                    updateLoadIcon();
                });
                document.getElementById('mViewBest').addEventListener('click', () => {
                    // closeSettings();  â† âŒ ì´ ì¤„ ì‚­ì œ!
                    if (bestGameState) {
                        renderMiniPopup(bestGameState, playerId, bestScore);
                    } else {
                        info("ì•„ì§ ì €ì¥ëœ ìµœê³  ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.", "warn");
                    }
                });

                document.getElementById('mResetId').addEventListener('click', () => { closeSettings(); askPlayerId(true); });
                document.getElementById('mRanking').addEventListener('click', () => {
                    closeSettings();
                    popup.classList.add('show');
                    rankingsEl.innerHTML = "<div style='padding:10px'>ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ì¤‘...</div>";
                    loadRanking();
                });
                document.getElementById('mExit').addEventListener('click', () => {
                    closeSettings();
                    window.location.href = "index.html"; // í•„ìš” ì‹œ íŒŒì¼ëª… ìˆ˜ì •
                });
                updateLoadIcon(); // âœ… ì´ˆê¸° ì‹¤í–‰ ì‹œ ì•„ì´ì½˜ ìƒíƒœ ë°˜ì˜
                // ğŸ”Š ì„¤ì • íŒì—… ë‚´ ëª¨ë“  ë²„íŠ¼ì— í´ë¦­ ì‚¬ìš´ë“œ ê³µí†µ ì ìš©
                document.querySelectorAll('#settingsPopup button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        try {
                            sounds.clickMenu.currentTime = 0;
                            sounds.clickMenu.play().catch(() => { });
                        } catch (e) { }
                    });
                });

            }

            /* ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸ */
            function highlightPath(path) {
                if (!path || path.length < 2) return;
                for (let i = 1; i < path.length; i++) {   // <--- ì—¬ê¸° ìˆ˜ì • ( -1 ì œê±° )
                    const cell = board.children[path[i].r * COLS + path[i].c];
                    if (cell) cell.classList.add('path-highlight');
                }
            }
            function clearPathHighlight() { board.querySelectorAll('.path-highlight').forEach(el => el.classList.remove('path-highlight')); }

            /* ====== ì´ë™ ====== */
            function onTapCell() {
                // âœ… grid ë¹„ì •ìƒ ìƒíƒœ ë°©ì–´ (ë¶ˆëŸ¬ì˜¤ê¸° ì§í›„ ì˜¤ë¥˜ ì˜ˆë°©)
                if (!Array.isArray(grid) || grid.length === 0) {
                    console.warn("âš ï¸ grid ë¹„ì •ìƒ ìƒíƒœ ê°ì§€, í´ë¦­ ë¬´ì‹œ");
                    return;
                }

                if (!gameActive || gameOverShown) return; // ğŸ¯ ê²Œì„ì˜¤ë²„ ìƒíƒœë©´ í´ë¦­ ì°¨ë‹¨
                if (hammerMode) return;
                if (isAnimating) return;

                const r = +this.dataset.r, c = +this.dataset.c;
                clearPossibleMoves();

                if (isTile(r, c)) {
                    selected = { r, c };
                    highlightSelection();
                    showPossibleMoves(r, c);
                    if (!board.querySelector('.possible-move')) info("ì´ë™ ê°€ëŠ¥í•œ ê³³ì´ ì—†ìŠµë‹ˆë‹¤.", "warn");
                    try { sounds.click.currentTime = 0; sounds.click.play().catch(() => { }); } catch (e) { }
                    return;
                }

                if (isEmpty(r, c) && selected) {
                    const from = { ...selected }, to = { r, c }, val = grid[from.r][from.c];
                    const reasons = [];
                    const path = findPathViaEmpties(from, to); if (!path) reasons.push("ê²½ë¡œê°€ ë§‰í˜€ ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    const gsize = groupSizeIfMoved(from, to, val); if (gsize < 2) reasons.push("ì´ë™í•´ë„ ê·¸ë£¹ì´ í˜•ì„±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
                    const currentGroup = floodSame(from.r, from.c, val);
                    if (currentGroup.length === 2 && gsize < 3) reasons.push("3ë§¤ì¹­ ëª©ì ì´ ì•„ë‹ˆë©´ ë‘ê°œë¥¼ ë–¼ì–´ ë†“ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    // ì´ë™ ì‹¤íŒ¨ ì‚¬ìœ  ëˆ„ì 
                    if (reasons.length > 0) {
                        // ë™ì¼ ì¹´í…Œê³ ë¦¬ ì´ë™ ì˜¤ë¥˜ëŠ” í•œ ë²ˆë§Œ ì¶œë ¥
                        const uniqueReasons = [...new Set(reasons)];
                        const combinedMsg = "ğŸš« ì´ë™ ë¶ˆê°€\n" + uniqueReasons.join("\n");

                        // ìµœê·¼ ê°™ì€ ì¹´í…Œê³ ë¦¬ ë©”ì‹œì§€ê°€ ë°”ë¡œ ì „ì— ë–´ë‹¤ë©´ ë¬´ì‹œ (1ì´ˆ ë‚´)
                        const now = Date.now();
                        if (!window.lastMoveToastTime || now - window.lastMoveToastTime > 1000) {
                            info(combinedMsg, "err");
                            window.lastMoveToastTime = now;
                        }
                        return;
                    }


                    isAnimating = true;

                    animateMoveTile(from, to, path, async () => {
                        const pivotIfMerge = (gsize >= 3) ? to : null;

                        try {
                            if (gsize >= 3) { sounds.mergeMove.currentTime = 0; sounds.mergeMove.play().catch(() => { }); }
                            else { sounds.move.currentTime = 0; sounds.move.play().catch(() => { }); }
                        } catch (e) { }

                        await completeTurnPipeline(pivotIfMerge);
                    });
                }
            }

            function animateMoveTile(from, to, path, callback) {
                const v = grid[from.r][from.c];
                const fromCell = board.children[from.r * COLS + from.c];
                const fromTile = fromCell.querySelector('.tile');

                if (!fromTile || !path || path.length < 2) {
                    moveTileInstant(from, to);
                    if (callback) callback();
                    return;
                }

                // âœ… ë§ì¹˜ ì•„ì´ì½˜ ì—¬ë¶€ ì €ì¥
                const hadHammer = fromTile.dataset.hammer === "1";

                addEmptyPlaceholderAt(from.r, from.c);
                const animatingTile = fromTile.cloneNode(true);
                animatingTile.classList.add('moving');
                highlightPath(path);

                grid[from.r][from.c] = 0;
                grid[to.r][to.c] = v;

                fromTile.style.visibility = 'hidden';
                drawCell(from.r, from.c);

                board.appendChild(animatingTile);
                setTilePosition(animatingTile, path[0]);

                animateStepByStep(animatingTile, path, 0, () => {
                    animatingTile.remove();
                    removePlaceholderAt(from.r, from.c);

                    drawCell(to.r, to.c);

                    // âœ… ì´ë™ ì™„ë£Œ í›„ ë§ì¹˜ ì•„ì´ì½˜ ë³µì›
                    if (hadHammer) {
                        const targetTile = board.children[to.r * COLS + to.c].querySelector('.tile');
                        if (targetTile && !targetTile.querySelector('.hammer-icon')) {
                            targetTile.dataset.hammer = "1";
                            const icon = document.createElement('img');
                            icon.src = "images/hammer.png";
                            icon.className = "hammer-icon";
                            targetTile.appendChild(icon);
                        }
                    }

                    clearPathHighlight();
                    const finalTile = board.children[to.r * COLS + to.c].querySelector('.tile');
                    if (finalTile) {
                        finalTile.classList.add('bump');
                        setTimeout(() => finalTile.classList.remove('bump'), 200);
                    }
                    if (callback) callback();
                });
            }


            function setTilePosition(tile, gridPos) {
                const targetCell = board.children[gridPos.r * COLS + gridPos.c];
                const rect = targetCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();
                tile.style.position = 'absolute';
                tile.style.left = (rect.left - boardRect.left) + 'px';
                tile.style.top = (rect.top - boardRect.top) + 'px';
                tile.style.width = targetCell.offsetWidth + 'px';
                tile.style.height = targetCell.offsetHeight + 'px';
                tile.style.transition = 'none';
            }

            function animateStepByStep(tile, path, currentStep, callback, speed = MOVE_SPEED) {
                if (currentStep >= path.length - 1) { if (callback) callback(); return; }
                const nextPos = path[currentStep + 1];
                const targetCell = board.children[nextPos.r * COLS + nextPos.c];
                const rect = targetCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();

                tile.style.transition = `left ${speed}ms ease-out, top ${speed}ms ease-out`;
                tile.style.left = (rect.left - boardRect.left) + 'px';
                tile.style.top = (rect.top - boardRect.top) + 'px';

                setTimeout(() => { animateStepByStep(tile, path, currentStep + 1, callback, speed); }, speed);
            }

            function moveTileInstant(from, to) {
                const v = grid[from.r][from.c];
                addEmptyPlaceholderAt(from.r, from.c);
                grid[from.r][from.c] = 0; grid[to.r][to.c] = v;
                drawCell(from.r, from.c); removePlaceholderAt(from.r, from.c);
                drawCell(to.r, to.c);
                const tCell = board.children[to.r * COLS + to.c].querySelector('.tile');
                if (tCell) { tCell.classList.add('bump'); setTimeout(() => tCell.classList.remove('bump'), 200); }
            }

            /* ====== ê²½ë¡œ íƒìƒ‰ ====== */
            // âœ… ì¶”ê°€: rock(-2) ê°’ë„ ë§‰íˆê²Œ ì²˜ë¦¬
            const isRock = (r, c) => grid[r][c] === -2;

            function findPathViaEmpties(from, to) {
                const q = [from],
                    prev = Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
                    vis = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                vis[from.r][from.c] = true;
                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                while (q.length) {
                    const cur = q.shift();
                    for (const [dr, dc] of dirs) {
                        const nr = cur.r + dr, nc = cur.c + dc;
                        if (!inBounds(nr, nc) || vis[nr][nc]) continue;
                        else if (isBlocked(nr, nc) || isRock(nr, nc) || isTile(nr, nc) || rockSet.has(`${nr},${nc}`)) continue;


                        vis[nr][nc] = true; prev[nr][nc] = cur;
                        if (nr === to.r && nc === to.c) {
                            const path = []; let x = { r: nr, c: nc };
                            while (x) { path.push(x); x = prev[x.r][x.c]; }
                            path.reverse(); return path;
                        }
                        q.push({ r: nr, c: nc });
                    }
                }
                return null;
            }

            function destAdjacentSame(to, val) {
                return [[1, 0], [-1, 0], [0, 1], [0, -1]]
                    .some(([dr, dc]) => inBounds(to.r + dr, to.c + dc) && grid[to.r + dr][to.c + dc] === val);
            }

            function floodSame(sr, sc, val, g = grid) {
                const vis = Array.from({ length: ROWS }, () => Array(COLS).fill(false)),
                    q = [{ r: sr, c: sc }], out = [];
                vis[sr][sc] = true;
                while (q.length) {
                    const { r, c } = q.shift(); out.push({ r, c });
                    for (const [dr, dc] of [[1, 0], [0, 1], [-1, 0], [0, -1]]) {
                        const nr = r + dr, nc = c + dc;
                        if (inBounds(nr, nc) && !vis[nr][nc] && g[nr][nc] === val) { vis[nr][nc] = true; q.push({ r: nr, c: nc }); }
                    }
                }
                return out;
            }

            function groupSizeIfMoved(from, to, val) {
                const tmp = cloneGrid(grid);
                // rockSetë„ ë°˜ì˜
                for (const pos of rockSet) {
                    const [r, c] = pos.split(',').map(Number);
                    tmp[r][c] = -2; // rockì€ ë§‰í˜ ì²˜ë¦¬
                }
                tmp[from.r][from.c] = 0;
                tmp[to.r][to.c] = val;
                return floodSame(to.r, to.c, val, tmp).length;
            }


            /* ====== ë³´ë“œ/ìƒˆê²Œì„ ====== */
            const makeGrid = () => Array.from({ length: ROWS }, () => Array(COLS).fill(0));

            function newGame() {
                popupTitle.textContent = "ê²Œì„ ì˜¤ë²„";
                grid = makeGrid();
                const blockedCount = 3; // 2~3 ëœë¤ ê°€ëŠ¥ ë“±ì¥ ë¸”ëŸ­ ê°¯ìˆ˜
                placeRandomBlocks(-1, blockedCount);

                placeRandomTilesAvoidingTriples(INIT_TILES, 400);
                renderAll(true);

                turn = 0; untilSpawn = SPAWN_EVERY; spawnCount = 0; selected = null; gameOverShown = false;
                elTurn.textContent = '0'; elNext.textContent = String(SPAWN_EVERY);
                elTurnMini.textContent = '0'; elNextMini.textContent = String(SPAWN_EVERY);
                updateMegaLeft();
                popup.classList.remove('show');
                checkGameOverSoon();

                // ğŸ§¹ rock ê´€ë ¨ ì”ì—¬ë¬¼ ì™„ì „ ì •ë¦¬
                document.querySelectorAll('.rock-block').forEach(el => el.remove());
                rockSet.clear();

                gameActive = true;
                window.pendingEnemyAttack = false;
            }

            // ğŸ¯ ì¶”ê°€ ì½”ë“œ
            gameActive = true;
            window.pendingEnemyAttack = false;
            /* ====== ì†Œí™˜ ====== */
            function placeRandomBlocks(v, count) {
                const E = listEmpty(); shuffle(E);
                for (let i = 0; i < count && i < E.length; i++) grid[E[i].r][E[i].c] = v;
            }
            function placeRandomTilesAvoidingTriples(count, maxTry = 200) {
                let placed = 0, tries = 0;
                while (placed < count && tries < maxTry) {
                    const E = listEmpty(); if (!E.length) break;
                    const p = E[(Math.random() * E.length) | 0], v = randomValue();
                    grid[p.r][p.c] = v;
                    if (findLowestGroupGE3()) { grid[p.r][p.c] = 0; } else { placed++; }
                    tries++;
                }
                if (placed < count) placeRandomTiles(count - placed);
            }
            function placeRandomTiles(count) {
                const E = listEmpty(); shuffle(E);
                for (let i = 0; i < count && i < E.length; i++) grid[E[i].r][E[i].c] = randomValue();
            }

            async function spawnBatch() {
                isAnimating = true;
                spawnCount++;

                if (spawnCount % MEGA_INTERVAL === 0) {
                    info("ğŸŒŸ ëŒ€ì†Œí™˜! ë¸”ë¡ 2ë°° ì†Œí™˜!");

                    // ğŸ”Š ëŒ€ì†Œí™˜ ì‚¬ìš´ë“œ ì¬ìƒ
                    try {
                        sounds.bigcall.currentTime = 0;
                        sounds.bigcall.play().catch(() => { });
                    } catch (e) { console.error(e); }

                    for (let i = 0; i < SPAWN_BATCH * 2; i++) spawnOne();
                }

                else {
                    for (let i = 0; i < SPAWN_BATCH; i++) spawnOne();
                }

                await sleep(SPAWN_TO_MERGE_DELAY);
                await resolveAutoMergesAsync(null);
                isAnimating = false;
            }

            function spawnOne() {
                const E = listEmpty(); if (!E.length) return false;
                const p = E[(Math.random() * E.length) | 0];
                grid[p.r][p.c] = randomValue();
                drawCell(p.r, p.c, { spawn: true });
                const t = board.children[p.r * COLS + p.c].querySelector('.tile');
                if (t) t.classList.add('spawn');
                return true;
            }

            /* ====== ë¨¸ì§€ ====== */
            function findPathWithinGroup(from, to, groupSet) {
                const q = [from], prev = new Map(), vis = new Set([key(from.r, from.c)]);
                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                while (q.length) {
                    const cur = q.shift();
                    if (cur.r === to.r && cur.c === to.c) {
                        const path = []; let k = key(cur.r, cur.c);
                        while (k) { const [rr, cc] = k.split(',').map(Number); path.push({ r: rr, c: cc }); k = prev.get(k); }
                        path.reverse(); return path;
                    }
                    for (const [dr, dc] of dirs) {
                        const nr = cur.r + dr, nc = cur.c + dc, nk = key(nr, nc);
                        if (!inBounds(nr, nc) || vis.has(nk)) continue;
                        if (!groupSet.has(nk)) continue;
                        vis.add(nk); prev.set(nk, key(cur.r, cur.c)); q.push({ r: nr, c: nc });
                    }
                }
                return null;
            }
            function manhattanFallbackPath(from, to) {
                const path = [{ r: from.r, c: from.c }];
                let r = from.r, c = from.c;
                while (r !== to.r) { r += (to.r > r ? 1 : -1); path.push({ r, c }); }
                while (c !== to.c) { c += (to.c > c ? 1 : -1); path.push({ r, c }); }
                return path;
            }
            function findLowestGroupGE3() {
                const seen = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                let best = null;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const v = grid[r][c];
                        if (v <= 0 || seen[r][c]) continue;
                        const comp = floodSame(r, c, v);
                        for (const p of comp) seen[p.r][p.c] = true;
                        if (comp.length >= 3) { if (!best || v < best.val) best = { val: v, group: comp }; }
                    }
                }
                return best;
            }

            function animateGroupMerge(group, pivot, val) {
                return new Promise((resolve) => {
                    const absorbers = group.filter(p => !(p.r === pivot.r && p.c === pivot.c)).slice(0, 2);
                    const gset = new Set(group.map(p => key(p.r, p.c)));

                    const paths = absorbers.map(src => {
                        let path = findPathWithinGroup(src, pivot, gset);
                        if (!path || path.length < 2) path = manhattanFallbackPath(src, pivot);
                        return path;
                    });

                    lockCell(pivot.r, pivot.c);

                    const clones = absorbers.map((src, i) => {
                        const cell = board.children[src.r * COLS + src.c];
                        const tile = cell.querySelector('.tile');
                        addEmptyPlaceholderAt(src.r, src.c);
                        const clone = tile ? tile.cloneNode(true) : null;
                        if (tile) tile.style.visibility = 'hidden';
                        if (clone) {
                            clone.classList.add('moving'); clone.style.zIndex = 500;
                            board.appendChild(clone);
                            setTilePosition(clone, paths[i][0]);
                        }
                        return { src, clone };
                    });

                    let finished = 0;
                    const onOneDone = () => { finished++; if (finished === paths.length) afterAllArrived(); };

                    clones.forEach((pack, i) => {
                        const cl = pack.clone;
                        if (!cl) { onOneDone(); return; }
                        animateStepByStep(cl, paths[i], 0, () => { onOneDone(); }, MERGE_SPEED);
                    });

                    async function afterAllArrived() {
                        clones.forEach(p => { if (p.clone) p.clone.remove(); });
                        // ğŸ”¨ ë¨¸ì§€ëœ ê·¸ë£¹ ë‚´ ë§ì¹˜ ê°œìˆ˜ ê³„ì‚°
                        const hammerCountInGroup = group.reduce((count, p) => {
                            const cell = board.children[p.r * COLS + p.c];
                            const t = cell && cell.querySelector('.tile[data-hammer="1"]');
                            return count + (t ? 1 : 0);
                        }, 0);

                        for (const p of absorbers) { grid[p.r][p.c] = 0; drawCell(p.r, p.c); }
                        grid[pivot.r][pivot.c] = val * 3;
                        drawCell(pivot.r, pivot.c, { force: true });
                        // ê¸°ì¡´ ë¶€ë¶„ (animateGroupMerge ë‚´ë¶€)
                        absorbers.forEach(p => removePlaceholderAt(p.r, p.c));

                        for (const p of absorbers) { grid[p.r][p.c] = 0; drawCell(p.r, p.c); }

                        // âœ… ìƒˆ ìƒìœ„ ë¸”ë¡ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë””ì½”ë”© í›„ ìƒì„±
                        const nextVal = val * 3;
                        const preloadImg = new Image();
                        preloadImg.src = TILE_IMAGES[nextVal];
                        preloadImg.decode().catch(() => { }); // ë””ì½”ë”© ì™„ë£Œ ëŒ€ê¸°

                        grid[pivot.r][pivot.c] = nextVal;
                        drawCell(pivot.r, pivot.c, { force: true });
                        unlockCell(pivot.r, pivot.c);

                        unlockCell(pivot.r, pivot.c);

                        const tCell = board.children[pivot.r * COLS + pivot.c].querySelector('.tile');
                        if (tCell) { tCell.classList.add('merge'); setTimeout(() => tCell.classList.remove('merge'), 240); }

                        try { if (sounds.blocks[val * 3]) { sounds.blocks[val * 3].currentTime = 0; sounds.blocks[val * 3].play().catch(() => { }); } } catch (e) { }
                        if (hammerCountInGroup > 0) {
                            hammerCount += hammerCountInGroup;
                            updateHammerUI();
                            info(`ğŸ”¨ ë§ì¹˜ ${hammerCountInGroup}ê°œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`, "ok");
                        }




                        resolve();
                    }
                });
            }

            async function resolveAutoMergesAsync(forcePivot = null) {
                let currentPivot = forcePivot ? { ...forcePivot } : null;

                while (true) {
                    if (currentPivot) {
                        const val = grid[currentPivot.r][currentPivot.c];
                        if (val > 0) {
                            const group = floodSame(currentPivot.r, currentPivot.c, val);
                            if (group.length >= 3) {
                                await animateGroupMerge(group, currentPivot, val);
                                saveSnapshot();
                                await sleep(MERGE_CHAIN_DELAY);
                                currentPivot = { r: currentPivot.r, c: currentPivot.c };
                                continue;
                            }
                        }
                    }
                    const pick = findLowestGroupGE3();
                    if (!pick) break;

                    const { val, group } = pick;
                    const pivot = group[0];
                    await animateGroupMerge(group, pivot, val);
                    saveSnapshot();
                    await sleep(MERGE_CHAIN_DELAY);
                    currentPivot = { r: pivot.r, c: pivot.c };
                }
            }

            async function completeTurnPipeline(pivotOrNull) {
                // ğŸš« ê²Œì„ì˜¤ë²„ ìƒíƒœë©´ í„´ ë¡œì§ ì™„ì „ ì°¨ë‹¨
                if (!gameActive || gameOverShown) return;
                await resolveAutoMergesAsync(pivotOrNull);

                turn++;
                untilSpawn--;

                let didSpawnThisTurn = false; // ğŸ”¥ ì´ë²ˆ í„´ì— ë¸”ëŸ­ ì†Œí™˜ì´ ìˆì—ˆëŠ”ì§€ ì²´í¬

                if (untilSpawn === 0) {
                    await spawnBatch();
                    untilSpawn = SPAWN_EVERY;
                    didSpawnThisTurn = true; // ì´ë²ˆ í„´ì—” ì†Œí™˜ ë°œìƒ
                }

                updateMegaLeft();
                saveSnapshot();
                elTurn.textContent = String(turn);
                elNext.textContent = String(untilSpawn);
                elTurnMini.textContent = String(turn);
                elNextMini.textContent = String(untilSpawn);
                selected = null;
                highlightSelection();
                clearPossibleMoves();

                isAnimating = false;

                // ==== ğŸª¨ ì ì˜ ê³µê²© ì‹œìŠ¤í…œ ====
                if (gameActive && !gameOverShown && !didSpawnThisTurn) {
                    if (window.pendingEnemyAttack) {
                        // ì´ì „ í„´ì— ì˜ˆê³ ëœ ê³µê²© ì‹¤í–‰
                        window.pendingEnemyAttack = false;
                        const empties = listEmpty();
                        if (empties.length > 0) {
                            const { r, c } = empties[Math.floor(Math.random() * empties.length)];
                            createRockAt(r, c);
                            queueInfo("ğŸ’¥ ì¸ê°„ì˜ ê³µê²©ìœ¼ë¡œ ê²½ë¡œ ì¼ë¶€ê°€ ë§‰í˜”ìŠµë‹ˆë‹¤!", "err");
                        }
                    } else {
                        // âœ… ë‹¤ìŒ í„´ ê³µê²© ì˜ˆê³  ì¡°ê±´:
                        // 1. ì´ë²ˆ í„´ì€ ì†Œí™˜ í„´ì´ ì•„ë‹˜
                        // 2. ë‹¤ìŒ í„´ì´ ì†Œí™˜ í„´ì´ ì•„ë‹˜ (untilSpawn > 1)
                        // 3. í™•ë¥  ì¶©ì¡±
                        if (untilSpawn > 1 && Math.random() < ENEMY_ATTACK_CHANCE) {
                            queueInfo("âš ï¸ ë‹¤ìŒ í„´ì— ì¸ê°„ì˜ ê³µê²©ì´ ë‚ ì•„ì˜µë‹ˆë‹¤!", "warn");
                            window.pendingEnemyAttack = true;

                            // ğŸ”Š ê²½ê³  ì‚¬ìš´ë“œ ì¬ìƒ
                            try {
                                sounds.warning.currentTime = 0;
                                sounds.warning.play().catch(() => { });
                            } catch (e) { console.error(e); }
                        }

                    }
                }

                checkGameOverSoon();

                flushToast();


                // í„´ì´ ëë‚  ë•Œë§ˆë‹¤ ì“°ë ˆê¸° ì •ë¦¬
                function cleanupDetachedNodes() {
                    document.querySelectorAll('.moving, .bomb-effect, .placeholder')
                        .forEach(el => el.remove());
                }

            }

            /* ====== ê²Œì„ì˜¤ë²„ ====== */
            function legalMoveExistsForTile(r, c) {
                const v = grid[r][c]; const currentGroup = floodSame(r, c, v);
                for (let rr = 0; rr < ROWS; rr++) for (let cc = 0; cc < COLS; cc++) {
                    if (!isEmpty(rr, cc)) continue;
                    const to = { r: rr, c: cc }; const path = findPathViaEmpties({ r, c }, to); if (!path) continue;
                    if (!destAdjacentSame(to, v)) continue;
                    const gsize = groupSizeIfMoved({ r, c }, to, v); if (gsize < 2) continue;
                    if (currentGroup.length === 2 && gsize < 3) continue;
                    return true;
                }
                return false;
            }
            function hasAnyMoves() {
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (grid[r][c] > 0 && legalMoveExistsForTile(r, c)) return true;
                return false;
            }
            function checkGameOverSoon() {
                setTimeout(() => {
                    if (!gameOverShown && !hasAnyMoves()) {
                        gameOverShown = true;
                        const total = grid.flat().filter(v => v > 0).reduce((a, b) => a + b, 0);
                        showResult(total);
                    }
                }, 30);
            }

            /* ====== íˆìŠ¤í† ë¦¬ ====== */
            function saveSnapshot() {
                history.push({ grid: cloneGrid(grid), turn, untilSpawn });
                if (history.length > 50) history.shift();
            }

            /* ====== ê²°ê³¼/ë­í‚¹ ====== */
            async function showResult(total) {
                // âœ… ê²Œì„ì˜¤ë²„ ì§„ì… ì‹œ ê³µê²© ì™„ì „ ì°¨ë‹¨
                gameActive = false;
                gameOverShown = true;
                window.pendingEnemyAttack = false;

                // í˜¹ì‹œ ì˜ˆì•½ëœ ê³µê²© íƒ€ì´ë¨¸ê°€ ìˆë‹¤ë©´ ì œê±°
                if (typeof window.enemyAttackTimer !== "undefined") {
                    clearTimeout(window.enemyAttackTimer);
                    window.enemyAttackTimer = null;
                }

                // í† ìŠ¤íŠ¸ ì¦‰ì‹œ ë‹«ê¸°
                if (toastTimer) clearTimeout(toastTimer);
                if (toast) toast.classList.remove('show');
                popupTitle.textContent = "ê²Œì„ ì˜¤ë²„";
                finalScore.textContent = `${playerId}ì˜ ìµœì¢… ì ìˆ˜: ${total}`;
                noMovesMsg.style.display = "block";
                lastGameState = cloneGrid(grid);

                if (total > bestScore) {
                    bestScore = total; bestGameState = cloneGrid(grid);
                    localStorage.setItem("mergeBestScore", bestScore);
                    localStorage.setItem("mergeBestState", JSON.stringify(bestGameState));
                }

                rankingsEl.innerHTML = "<div style='padding:10px'>ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ì¤‘...</div>";
                popup.classList.add('show');

                try { sounds.gameover.currentTime = 0; sounds.gameover.play().catch(() => { }); } catch (e) { }

                try {
                    await fetch(GAS_URL, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ secret: "TEST2", name: playerId, score: total, state: grid }),
                        mode: "no-cors"
                    });
                } catch (e) { console.error("âŒ POST ì˜¤ë¥˜:", e); }

                loadRanking();
            }

            async function loadRanking() {
                try {
                    const res = await fetch(`${GAS_URL}?mode=ranking`, { cache: "no-cache" });
                    let data = []; try { data = await res.json(); } catch (e) { console.error("âŒ JSON íŒŒì‹± ì‹¤íŒ¨:", e); }
                    renderRanking(Array.isArray(data) ? data.slice(0, 100) : []);
                } catch (e) {
                    console.error("âŒ ë­í‚¹ fetch ì‹¤íŒ¨:", e);
                    renderRanking([]);
                }
            }

            function renderRanking(rows) {
                rankingsEl.innerHTML = "";
                if (!rows || rows.length === 0) {
                    const empty = document.createElement('div'); empty.style.padding = '10px';
                    empty.textContent = 'ë­í‚¹ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.'; rankingsEl.appendChild(empty); return;
                }
                rows.forEach((row, i) => {
                    const item = document.createElement('div');
                    item.className = 'rank-item' + (i === 0 ? ' top1' : i === 1 ? ' top2' : i === 2 ? ' top3' : '');
                    const left = document.createElement('div'); left.className = 'left';
                    const crown = document.createElement('span'); crown.className = 'crown'; crown.textContent = (i < 3 ? 'ğŸ‘‘' : ''); left.appendChild(crown);
                    const name = document.createElement('span'); name.textContent = `${i + 1}. ${row.name}`; left.appendChild(name);

                    const right = document.createElement('div'); right.className = 'right';
                    if (i < 3) {
                        const btn = document.createElement('button'); btn.textContent = "ë³´ê¸°"; btn.className = "btn";
                        btn.addEventListener('click', async () => {
                            try {
                                if (row.state) { renderMiniPopup(JSON.parse(row.state), row.name, row.score); }
                                else {
                                    const res = await fetch(`${GAS_URL}?mode=last&name=${encodeURIComponent(row.name)}`);
                                    const data = await res.json();
                                    if (data.state) renderMiniPopup(JSON.parse(data.state), data.name, data.score);
                                    else alert("ì €ì¥ëœ ì „ì ì´ ì—†ìŠµë‹ˆë‹¤.");
                                }
                            } catch (e) { console.error("âŒ last fetch ì˜¤ë¥˜:", e); alert("ì „ì ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
                        });
                        right.appendChild(btn);
                    }
                    const score = document.createElement('span'); score.className = 'score'; score.textContent = `${row.score}`;
                    right.appendChild(score);

                    item.appendChild(left); item.appendChild(right); rankingsEl.appendChild(item);
                });
            }

            /* ====== ë¯¸ë‹ˆíŒì—… ====== */
            function renderMiniPopup(state, id, score) {
                let mini = document.getElementById('miniPopup');
                if (!mini) {
                    mini = document.createElement('div'); mini.id = 'miniPopup';
                    mini.style.position = 'fixed'; mini.style.inset = '0'; mini.style.background = 'rgba(0,0,0,0.6)';
                    mini.style.display = 'flex'; mini.style.alignItems = 'center'; mini.style.justifyContent = 'center';
                    mini.style.zIndex = '3000'; document.body.appendChild(mini);
                }
                mini.innerHTML = '';
                const box = document.createElement('div');
                box.style.background = '#161c29'; box.style.padding = '16px'; box.style.borderRadius = '12px';
                box.style.textAlign = 'center'; box.style.boxShadow = '0 6px 20px rgba(0,0,0,0.6)';
                const title = document.createElement('h3'); title.textContent = `${id} ìµœì¢… ë³´ë“œ (ì ìˆ˜ ${score})`; box.appendChild(title);

                const wrap = document.createElement('div');
                wrap.style.display = 'grid';
                wrap.style.gridTemplateColumns = `repeat(${COLS},1fr)`;
                wrap.style.gridTemplateRows = `repeat(${ROWS},1fr)`;
                wrap.style.gap = '4px'; wrap.style.width = '90%'; wrap.style.maxWidth = '420px';
                wrap.style.aspectRatio = `${COLS}/${ROWS}`; wrap.style.margin = '12px auto';
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = '100%'; cell.style.aspectRatio = '1/1'; cell.style.border = '1px solid #222'; cell.style.background = '#111';
                    const v = state[r][c];
                    if (v > 0 && TILE_IMAGES[v]) { cell.style.backgroundImage = `url(${TILE_IMAGES[v]})`; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    else if (v === -1) { cell.style.backgroundImage = "url('images/blocked.png')"; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    else { cell.style.backgroundImage = "url('images/empty.png')"; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    wrap.appendChild(cell);
                }
                box.appendChild(wrap);
                const close = document.createElement('button'); close.textContent = 'ë‹«ê¸°'; close.className = 'btn'; close.style.marginTop = '10px'; close.onclick = () => mini.remove(); box.appendChild(close);
                mini.appendChild(box);
            }

            /* ====== í† ìŠ¤íŠ¸ ë‹«ê¸° (ë‘ ê°œ ëª¨ë‘ í´ë¦­ ì‹œ ì¦‰ì‹œ ë‹«í˜) ====== */
            document.addEventListener('click', (e) => {
                const t1 = document.getElementById('toast');
                const t2 = document.getElementById('toast2');

                // í´ë¦­ëœ ëŒ€ìƒì´ í† ìŠ¤íŠ¸ ì˜ì—­ì´ë¼ë©´ ê·¸ëƒ¥ í†µê³¼ (ë‹«ì§€ ì•ŠìŒ)
                if (e.target.closest('#toast') || e.target.closest('#toast2')) return;

                // #toast ë‹«ê¸°
                if (t1 && t1.classList.contains('show')) {
                    t1.classList.remove('show');
                    if (t1._timer) clearTimeout(t1._timer);
                }

                // #toast2 ë‹«ê¸°
                if (t2 && t2.classList.contains('show')) {
                    t2.classList.remove('show');
                    if (t2._timer) clearTimeout(t2._timer);
                }
            }, true);

            /* ====== ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ====== */
            function saveGameToLocal() {
                try {
                    const saveObj = {
                        grid,
                        turn,
                        untilSpawn,
                        spawnCount,
                        bestScore,
                        playerId,
                        hammerCount // âœ… ë§ì¹˜ ê°¯ìˆ˜ë„ ì €ì¥
                    };
                    localStorage.setItem("mergeSave", JSON.stringify(saveObj));
                    return true;
                } catch (e) {
                    console.error("save fail", e);
                    return false;
                }
            }


            function loadGameFromLocal() {
                try {
                    const raw = localStorage.getItem("mergeSave");
                    if (!raw) return false;
                    const obj = JSON.parse(raw);
                    if (!obj || !Array.isArray(obj.grid)) return false;

                    grid = obj.grid.map(row => row.slice());
                    turn = Number(obj.turn) || 0;
                    untilSpawn = Number(obj.untilSpawn) || SPAWN_EVERY;
                    spawnCount = Number(obj.spawnCount) || 0;
                    bestScore = Number(obj.bestScore) || bestScore;
                    hammerCount = Number(obj.hammerCount) || 0; // âœ… ë§ì¹˜ ê°¯ìˆ˜ ë³µì›
                    updateHammerUI(); // âœ… UI ì—…ë°ì´íŠ¸

                    if (obj.playerId) {
                        playerId = obj.playerId;
                        localStorage.setItem("mergePlayerId", playerId);
                    }

                    updateMegaLeft();
                    selected = null;
                    highlightSelection();
                    clearPossibleMoves();

                    // âœ… ë¶ˆëŸ¬ì˜¤ê¸° ì‹œ í•­ìƒ ë‹¤ì‹œ í”Œë ˆì´ ê°€ëŠ¥ ìƒíƒœë¡œ ì „í™˜
                    gameActive = true;
                    gameOverShown = false;
                    window.pendingEnemyAttack = false;
                    popup.classList.remove('show'); // ê²°ê³¼ì°½ ë‹«ê¸°

                    // âœ… ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ í›„ ì €ì¥ë°ì´í„° ì¦‰ì‹œ íê¸°
                    localStorage.removeItem("mergeSave");
                    // âœ… rockSet ì´ˆê¸°í™” (ì°Œêº¼ê¸° ì œê±°)
                    rockSet.clear();
                    return true;
                } catch (e) {
                    console.error("load fail", e);
                    return false;
                }
            }



            /* ====== ì‹œì‘ ====== */
            preloadImages(IMAGE_URLS)
                .then(() => decodeAllBlockImages())  // âœ… ë””ì½”ë”©ê¹Œì§€ ì™„ë£Œ
                .then(() => init());


        })(); // IIFE ë

        // ğŸµ ì²« í„°ì¹˜/í´ë¦­ ì‹œ BGM ì‹œì‘ + ì‹œì‘ ë©”ì‹œì§€ ìˆ¨ê¹€
        function startBgm() {
            if (sounds.bgm && sounds.bgm.paused) {
                sounds.bgm.play().then(() => { console.log("ğŸ¶ BGM ì‹œì‘ë¨"); }).catch(err => { console.log("ğŸ”‡ BGM ì‹œì‘ ì‹¤íŒ¨:", err); });
            }
        }
        function hideStartMsg() { const m = document.getElementById("startMsg"); if (m) m.classList.add("hide"); }
        document.addEventListener("touchstart", () => { startBgm(); hideStartMsg(); }, { once: true });
        document.addEventListener("click", () => { startBgm(); hideStartMsg(); }, { once: true });

        // ì•±/íƒ­ ì „í™˜ ì‹œ BGM ì œì–´
        function pauseBgm() { if (window.sounds && window.sounds.bgm && !window.sounds.bgm.paused) { sounds.bgm.pause(); } }
        function resumeBgm() { if (window.sounds && window.sounds.bgm) { sounds.bgm.play().catch(err => console.log("ì¬ìƒ ì‹¤íŒ¨:", err)); } }
        document.addEventListener("visibilitychange", () => { if (document.hidden) pauseBgm(); else resumeBgm(); });
        window.addEventListener("pagehide", pauseBgm);
        window.addEventListener("pageshow", resumeBgm);
        window.addEventListener("blur", pauseBgm);
        window.addEventListener("focus", resumeBgm);
        // ğŸ¬ ì¸ê²Œì„ ì§„ì… ì‹œ í˜ì´ë“œ ì¸
        window.addEventListener("DOMContentLoaded", () => {
            const fade = document.getElementById("fadeLayer");
            if (fade) {
                requestAnimationFrame(() => {
                    fade.classList.add("fade-in");
                    setTimeout(() => fade.remove(), 400);
                });
            }
        });


    </script>
    <!-- âœ… í˜ì´ë“œ ì¸ ë ˆì´ì–´ -->
    <div id="fadeLayer"></div>
</body>
</html>