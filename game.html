<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <title>3Îß§Ïπ≠</title>
    <style>
        :root {
            --cols: 5;
            --rows: 7;
            --gap: 1vw;
            --bg: #0b0f14;
            --fg: #e8f0ff;
            --muted: #7f8da3;
            --tile: #18202b;
            --blocked: #161922;
            --accent: #46d3ff;
            --ok: #67ff9a;
            --warn: #ffcc4d;
            --err: #ff6b6b;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent
        }

        html, body {
            height: 100%
        }

        body {
            margin: 0;
            background: url('images/bg.png') no-repeat center center fixed;
            background-size: cover;
            color: var(--fg);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        header {
            width: 100%;
            max-width: 480px;
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: linear-gradient(180deg,rgba(11,15,20,0.95),rgba(11,15,20,0.6) 70%,transparent);
            backdrop-filter: blur(6px);
        }

        #title {
            font-size: 23px;
            font-weight: 700;
            color: #fff;
            text-align: center
        }

        .stat {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center
        }

        .idtag {
            padding: 2px 6px;
            border: 1px solid #2a3443;
            border-radius: 8px;
            color: #cfe5ff;
            background: #121722
        }

        #version {
            font-size: 11px;
            color: #6f7f95
        }

        #boardWrap {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px
        }

        #board {
            width: min(100vw, 540px);
            aspect-ratio: 5/7;
            display: grid;
            grid-template-columns: repeat(var(--cols), 1fr);
            grid-template-rows: repeat(var(--rows), 1fr);
            gap: var(--gap);
            position: relative;
            margin: 0 auto;
            overflow: visible;
        }

        .cell {
            aspect-ratio: 1/1;
            background: transparent;
            border: 1px solid #1c2736;
            border-radius: 14px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
        }

            .cell::after {
                content: "";
                position: absolute;
                inset: 0;
                border-radius: 14px;
                pointer-events: none;
                box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
            }

            .cell.blocked {
                background: var(--blocked);
                background-image: repeating-linear-gradient(135deg,#1f2533 0 8px,#141925 8px 16px);
                border-color: #20283a;
            }

            .cell.possible-move {
                background-color: rgba(70, 211, 255, 0.2);
                box-shadow: inset 0 0 12px rgba(70, 211, 255, 0.8);
                border-radius: 14px;
            }

            .cell.path-highlight {
                background-color: rgba(255, 204, 77, 0.3);
                box-shadow: inset 0 0 8px rgba(255, 204, 77, 0.6);
            }

        .tile {
            position: absolute;
            inset: 0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            user-select: none;
            -webkit-user-select: none;
            transition: transform .15s ease;
        }

            .tile.sel {
                border: 3px solid var(--accent);
                transform: scale(1.1);
                box-shadow: 0 0 15px var(--accent),0 0 25px rgba(70,211,255,0.7);
                z-index: 10;
            }

            .tile.spawn {
                animation: pop .22s ease-out;
                z-index: 300;
            }

            .tile.bump {
                animation: bump .18s ease-out;
            }

            .tile.merge {
                animation: merge .22s ease-in-out;
            }

            .tile.moving {
                z-index: 200;
                pointer-events: none;
                box-shadow: 0 4px 12px rgba(70, 211, 255, 0.6);
                transform: scale(1.1);
                border: 2px solid var(--accent);
                border-radius: 12px;
            }

            .tile.placeholder {
                position: absolute;
                inset: 0;
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                pointer-events: none;
                z-index: 0;
            }

        @keyframes pop {
            from {
                transform: scale(0.6);
                opacity: 0
            }

            to {
                transform: scale(1);
                opacity: 1
            }
        }

        @keyframes bump {
            0% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.08)
            }

            100% {
                transform: scale(1)
            }
        }

        @keyframes merge {
            0% {
                transform: scale(0.95)
            }

            50% {
                transform: scale(1.12)
            }

            100% {
                transform: scale(1)
            }
        }

        #controlBar {
            width: 100%;
            max-width: 480px;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            padding: 10px 0 16px;
        }

        .btn {
            appearance: none;
            border: 1px solid #2a3443;
            background: #121722;
            color: var(--fg);
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform .05s ease-out,background .2s;
        }

            .btn:active {
                transform: scale(0.98)
            }

        .msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%,-50%);
            background: rgba(17,26,40,0.7);
            border: 2px solid #223043;
            padding: 16px 24px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: bold;
            color: #ffcc4d;
            opacity: 0;
            min-width: 420px;
            max-width: 90vw;
            white-space: pre-line;
            transition: opacity .5s ease;
            z-index: 1000;
            pointer-events: none;
            line-height: 3;
            text-align: center;
        }

            .msg.show {
                opacity: 1
            }

        #startMsg.hide {
            display: none;
        }

        #resultPopup {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.65);
            z-index: 999;
            visibility: hidden;
            opacity: 0;
            transition: opacity .25s;
        }

            #resultPopup.show {
                visibility: visible;
                opacity: 1
            }

        #resultBox {
            background: #161c29;
            padding: 24px;
            border-radius: 16px;
            text-align: center;
            min-width: 360px;
            max-width: 96vw;
            box-shadow: 0 10px 28px rgba(0,0,0,0.6);
        }

            #resultBox h2 {
                margin: 0 0 8px;
                font-size: 20px;
            }

            #resultBox p {
                margin: 6px 0;
                font-size: 14px;
                color: var(--muted);
            }

            #resultBox .btn {
                margin-top: 12px;
            }

        #rankHeader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        #rankings {
            margin-top: 10px;
            max-height: 320px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #2a3443;
            border-radius: 10px;
        }

        .rank-item {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 6px 10px;
            border-bottom: 1px solid #222a3b;
            font-size: 14px;
            gap: 10px;
        }

            .rank-item .left {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .rank-item .right {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .rank-item .score {
                min-width: 60px;
                text-align: right;
            }

            .rank-item .btn {
                font-size: 12px;
                padding: 2px 6px;
                height: 22px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                position: relative;
                top: -6px;
            }

        .crown {
            font-size: 16px;
            line-height: 1
        }

        .top1 .crown {
            color: gold;
            filter: drop-shadow(0 0 6px rgba(255,215,0,.35))
        }

        .top2 .crown {
            color: silver;
            filter: drop-shadow(0 0 6px rgba(192,192,192,.3))
        }

        .top3 .crown {
            color: #cd7f32;
            filter: drop-shadow(0 0 6px rgba(205,127,50,.3))
        }

        #noMovesMsg {
            margin-top: 8px;
            font-size: 13px;
            color: var(--warn);
        }
    </style>
</head>
<body>
    <header>
        <div id="title">3Í∞úÏùò Î™¨Ïä§ÌÑ∞Î•º Ìï©ÏπòÏÑ∏Ïöî</div>
        <div class="stat">
            <span class="idtag" id="idView">ID: -</span>
            <span>ÌÑ¥: <b id="turn">0</b></span>
            <span>Îã§Ïùå ÏÜåÌôò: <b id="nextSpawn">3</b></span>
            <span>ÎåÄÏÜåÌôò ÎÇ®Ïùå: <b id="megaLeft">5</b></span>
            <span id="version">v1.7.0</span>
        </div>
    </header>

    <div id="boardWrap">
        <div id="board"></div>
        <div id="controlBar">
            <button class="btn" id="btnNew">ÏÉà Í≤åÏûÑ</button>
            <button class="btn" id="btnResetId">ÏïÑÏù¥Îîî Ï¥àÍ∏∞Ìôî</button>
            <button class="btn" id="btnRankManual">Îû≠ÌÇπ Î∂àÎü¨Ïò§Í∏∞</button>
        </div>
    </div>

    <div class="msg" id="toast"></div>
    <div class="msg show" id="startMsg">Î™¨Ïä§ÌÑ∞ ÌÉ≠!</div>

    <div id="resultPopup">
        <div id="resultBox">
            <h2 id="popupTitle">Í≤åÏûÑ Ïò§Î≤Ñ</h2>
            <p id="finalScore"></p>
            <p id="noMovesMsg" style="display:none;">Ïù¥Îèô Í∞ÄÎä•Ìïú ÏÜåÌôòÏàòÍ∞Ä ÏóÜÏäµÎãàÎã§.</p>
            <div id="rankHeader"><h3 style="margin:0;font-size:16px;">Îû≠ÌÇπ TOP 100</h3></div>
            <div id="rankings"><div style="padding:10px">Îû≠ÌÇπÏùÑ Î∂àÎü¨Ïò§ÎäîÏ§ë...</div></div>
            <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;">
                <button class="btn" id="btnRestart">Îã§Ïãú ÏãúÏûë</button>
                <button class="btn" id="btnBack">ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                <button class="btn" id="btnViewBest">ÎÇ¥ ÏµúÍ≥† Í∏∞Î°ù ÌôïÏù∏</button>
            </div>
        </div>
    </div>
    <script>
        (() => {
            /* ====== Ïù¥ÎØ∏ÏßÄ ÌîÑÎ¶¨Î°úÎìú ====== */
            function preloadImages(urls) {
                return Promise.all(urls.map(src => new Promise(res => {
                    const img = new Image(); img.onload = res; img.onerror = res; img.src = src;
                })));
            }
            const IMAGE_URLS = [
                "images/block-1.png", "images/block-2.png", "images/block-3.png",
                "images/block-4.png", "images/block-5.png", "images/block-6.png",
                "images/block-7.png", "images/block-8.png", "images/block-9.png",
                "images/blocked.png", "images/empty.png", "images/bg.png"
            ];

            /* ====== üéµ ÏÇ¨Ïö¥Îìú Î°úÎìú ====== */
            window.sounds = {
                bgm: new Audio("sounds/bgm.mp3"),
                move: new Audio("sounds/move.mp3"),
                click: new Audio("sounds/click.mp3"),
                toast: new Audio("sounds/toast.mp3"),
                gameover: new Audio("sounds/gameover.mp3"),
                blocks: {
                    3: new Audio("sounds/block-2.mp3"),
                    9: new Audio("sounds/block-3.mp3"),
                    27: new Audio("sounds/block-4.mp3"),
                    81: new Audio("sounds/block-5.mp3"),
                    243: new Audio("sounds/block-6.mp3"),
                    729: new Audio("sounds/block-7.mp3"),
                    2187: new Audio("sounds/block-8.mp3"),
                    6561: new Audio("sounds/block-9.mp3")
                }
            };
            sounds.bgm.loop = true;
            sounds.bgm.volume = 1;
            sounds.move.volume = 1;
            sounds.click.volume = 1;
            sounds.toast.volume = 1;
            sounds.gameover.volume = 1;
            for (let k in sounds.blocks) sounds.blocks[k].volume = 1;

            /* ====== Í∏∞Î≥∏ ÏÑ§Ï†ï ====== */
            const GAS_URL = "https://script.google.com/macros/s/AKfycbwIJmiCseB5UAQjfTIKN_812VkvXdLqmTObnq01JGxJV6D3T5TzKdsrU26_qbxQGGPq/exec";
            const COLS = 5, ROWS = 7;
            const INIT_TILES = 12;
            const SPAWN_EVERY = 3;
            const SPAWN_BATCH = 3;
            const MEGA_INTERVAL = 5;

            const TILE_IMAGES = {
                1: "images/block-1.png", 3: "images/block-2.png", 9: "images/block-3.png",
                27: "images/block-4.png", 81: "images/block-5.png", 243: "images/block-6.png",
                729: "images/block-7.png", 2187: "images/block-8.png", 6561: "images/block-9.png"
            };

            let grid = [], turn = 0, untilSpawn = SPAWN_EVERY, spawnCount = 0, selected = null, history = [], gameOverShown = false;
            let lastGameState = null, bestScore = 0, bestGameState = null;
            let isAnimating = false;

            const board = document.getElementById('board');
            const elTurn = document.getElementById('turn'),
                elNext = document.getElementById('nextSpawn'),
                elMega = document.getElementById('megaLeft');
            const toast = document.getElementById('toast');
            let toastTimer = null;

            function info(t, k) {
                toast.textContent = t;
                toast.style.color = k === 'err' ? 'var(--err)' : (k === 'warn' ? 'var(--warn)' : 'var(--fg)');
                toast.classList.remove('show'); void toast.offsetWidth; toast.classList.add('show');
                try { sounds.toast.currentTime = 0; sounds.toast.play().catch(() => { }); } catch (e) { }
                if (toastTimer) clearTimeout(toastTimer);
                toastTimer = setTimeout(() => { toast.classList.remove('show'); toastTimer = null; }, 2000);
            }

            const popup = document.getElementById('resultPopup'),
                finalScore = document.getElementById('finalScore'),
                popupTitle = document.getElementById('popupTitle');
            const idView = document.getElementById('idView');
            const rankingsEl = document.getElementById('rankings');
            const noMovesMsg = document.getElementById('noMovesMsg');

            /* ====== ÏïÑÏù¥Îîî ====== */
            let playerId = localStorage.getItem("mergePlayerId");
            function askPlayerId(force = false) {
                if (!playerId || force) {
                    let input = "";
                    while (!input) {
                        input = prompt("ÌîåÎ†àÏù¥Ïñ¥ ÏïÑÏù¥ÎîîÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî:");
                        if (input === null) { input = ""; }
                    }
                    playerId = input.trim();
                    localStorage.setItem("mergePlayerId", playerId);
                    info(`ÏïÑÏù¥Îîî ÏÑ§Ï†ïÎê®: ${playerId}`);
                }
                idView.textContent = "ID: " + playerId;
            }

            /* ====== Ïú†Ìã∏ ====== */
            const key = (r, c) => `${r},${c}`;
            function cloneGrid(g) { return g.map(r => r.slice()); }
            function inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
            function isEmpty(r, c) { return grid[r][c] === 0; }
            function isBlocked(r, c) { return grid[r][c] === -1; }
            function isTile(r, c) { return grid[r][c] > 0; }
            function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]]; } }
            function listEmpty() { const out = []; for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (grid[r][c] === 0) out.push({ r, c }); return out; }
            function randomValue() { return [1, 1, 1, 1, 3, 3, 9][(Math.random() * 7) | 0]; }

            /* ÍπúÎπ°ÏûÑ Î∞©ÏßÄ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî */
            function addEmptyPlaceholderAt(r, c) {
                const cell = board.children[r * COLS + c];
                if (!cell) return;
                if (cell.querySelector('.placeholder')) return;
                const ph = document.createElement('div');
                ph.className = 'tile placeholder';
                ph.style.backgroundImage = "url('images/empty.png')";
                cell.appendChild(ph);
            }
            function removePlaceholderAt(r, c) {
                const cell = board.children[r * COLS + c];
                if (!cell) return;
                const ph = cell.querySelector('.placeholder');
                if (ph) ph.remove();
            }

            /* ====== ÏÖÄ & Î†åÎçîÎßÅ ====== */
            function drawCell(r, c, opt = {}) {
                const idx = r * COLS + c, cell = board.children[idx];
                cell.classList.toggle('blocked', isBlocked(r, c));
                // Î™®Îì† ÌÉÄÏùºÎ•ò Ï†ïÎ¶¨(placeholderÎäî Ïú†ÏßÄ)
                const tiles = cell.querySelectorAll('.tile:not(.placeholder)');
                tiles.forEach(n => n.remove());
                const v = grid[r][c];
                if (v > 0) {
                    const t = document.createElement('div'); t.className = 'tile'; t.dataset.val = v;
                    if (opt.spawn) t.classList.add('spawn');
                    if (TILE_IMAGES[v]) t.style.backgroundImage = `url(${TILE_IMAGES[v]})`;
                    cell.appendChild(t);
                } else if (v === -1) {
                    const b = document.createElement('div'); b.className = 'tile'; b.style.backgroundImage = "url('images/blocked.png')"; cell.appendChild(b);
                } else {
                    const e = document.createElement('div'); e.className = 'tile'; e.style.backgroundImage = "url('images/empty.png')"; cell.appendChild(e);
                }
            }

            function updateMegaLeft() {
                const batchesSinceLastMega = spawnCount % MEGA_INTERVAL;
                const remBatches = (MEGA_INTERVAL - batchesSinceLastMega) || MEGA_INTERVAL;
                const movesLeft = (remBatches - 1) * SPAWN_EVERY + untilSpawn;
                elMega.textContent = String(movesLeft);
            }

            function renderAll(spawn = false) {
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) drawCell(r, c, { spawn: spawn && isTile(r, c) });
                elTurn.textContent = String(turn); elNext.textContent = String(untilSpawn); updateMegaLeft();
            }

            function highlightSelection() {
                for (const cell of board.children) { const t = cell.querySelector('.tile'); if (t) t.classList.remove('sel'); }
                if (selected) { const tile = board.children[selected.r * COLS + selected.c].querySelector('.tile'); if (tile) tile.classList.add('sel'); }
            }

            /* ====== Ïù¥Îèô Í∞ÄÎä• ÏúÑÏπò ÌëúÏãú ====== */
            function clearPossibleMoves() {
                board.querySelectorAll('.possible-move').forEach(el => el.classList.remove('possible-move'));
                board.querySelectorAll('.path-highlight').forEach(el => el.classList.remove('path-highlight'));
            }

            function showPossibleMoves(r, c) {
                const val = grid[r][c];
                const currentGroup = floodSame(r, c, val);
                for (let tr = 0; tr < ROWS; tr++) {
                    for (let tc = 0; tc < COLS; tc++) {
                        if (!isEmpty(tr, tc)) continue;
                        const to = { r: tr, c: tc };
                        const path = findPathViaEmpties({ r, c }, to);
                        if (!path) continue;
                        const gsize = groupSizeIfMoved({ r, c }, to, val);
                        if (gsize < 2) continue;
                        if (currentGroup.length === 2 && gsize < 3) continue;
                        board.children[tr * COLS + tc].classList.add('possible-move');
                    }
                }
            }
            /* ====== Ï¥àÍ∏∞Ìôî ====== */
            function init() {
                askPlayerId();

                const savedBest = Number(localStorage.getItem("mergeBestScore") || 0);
                if (!Number.isNaN(savedBest)) bestScore = savedBest;
                try {
                    const savedState = localStorage.getItem("mergeBestState");
                    if (savedState) bestGameState = JSON.parse(savedState);
                } catch (e) { console.warn("best state parse fail", e); }

                board.innerHTML = '';
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell'; cell.dataset.r = r; cell.dataset.c = c;
                        cell.addEventListener('click', onTapCell);
                        board.appendChild(cell);
                    }
                }
                newGame();

                document.getElementById('btnRestart').addEventListener('click', () => { popup.classList.remove('show'); newGame(); });
                document.getElementById('btnBack').addEventListener('click', () => { popup.classList.remove('show'); });
                document.getElementById('btnViewBest').addEventListener('click', () => {
                    if (bestGameState) { renderMiniPopup(bestGameState, playerId, bestScore); }
                    else alert("ÏïÑÏßÅ ÏµúÍ≥† Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.");
                });
                document.getElementById('btnNew').addEventListener('click', () => { newGame(); });
                document.getElementById('btnResetId').addEventListener('click', () => { askPlayerId(true); });

                document.getElementById('btnRankManual').addEventListener('click', () => {
                    popup.classList.add('show');
                    rankingsEl.innerHTML = "<div style='padding:10px'>Îû≠ÌÇπÏùÑ Î∂àÎü¨Ïò§ÎäîÏ§ë...</div>";
                    loadRanking();
                });
            }

            /* Í≤ΩÎ°ú ÌïòÏù¥ÎùºÏù¥Ìä∏ */
            function highlightPath(path) {
                if (!path || path.length < 2) return;
                for (let i = 1; i < path.length - 1; i++) {
                    const cell = board.children[path[i].r * COLS + path[i].c];
                    if (cell) cell.classList.add('path-highlight');
                }
            }
            function clearPathHighlight() { board.querySelectorAll('.path-highlight').forEach(el => el.classList.remove('path-highlight')); }

            /* ====== Ïù¥Îèô ====== */
            function onTapCell() {
                if (isAnimating) return;
                const r = +this.dataset.r, c = +this.dataset.c;
                clearPossibleMoves();

                if (isTile(r, c)) {
                    selected = { r, c };
                    highlightSelection();
                    showPossibleMoves(r, c);
                    if (!board.querySelector('.possible-move')) info("Ïù¥Îèô Í∞ÄÎä•Ìïú Í≥≥Ïù¥ ÏóÜÏäµÎãàÎã§.", "warn");
                    try { sounds.click.currentTime = 0; sounds.click.play().catch(() => { }); } catch (e) { }
                    return;
                }

                if (isEmpty(r, c) && selected) {
                    const from = { ...selected }, to = { r, c }, val = grid[from.r][from.c];
                    const reasons = [];
                    const path = findPathViaEmpties(from, to); if (!path) reasons.push("Í≤ΩÎ°úÍ∞Ä ÎßâÌòÄ Ïù¥ÎèôÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
                    const gsize = groupSizeIfMoved(from, to, val); if (gsize < 2) reasons.push("Ïù¥ÎèôÌï¥ÎèÑ Í∑∏Î£πÏù¥ ÌòïÏÑ±ÎêòÏßÄ ÏïäÏäµÎãàÎã§.");
                    const currentGroup = floodSame(from.r, from.c, val);
                    if (currentGroup.length === 2 && gsize < 3) reasons.push("3Îß§Ïπ≠ Î™©Ï†ÅÏù¥ ÏïÑÎãàÎ©¥ ÎëêÍ∞úÎ•º ÎñºÏñ¥ ÎÜìÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
                    if (reasons.length > 0) { info(reasons.join("\n"), "err"); return; }

                    isAnimating = true; // Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ Ïû†Í∏à

                    animateMoveTile(from, to, path, async () => {
                        const pivotIfMerge = (gsize >= 3) ? to : null;
                        await completeTurnPipeline(pivotIfMerge);
                    });
                }
            }

            function animateMoveTile(from, to, path, callback) {
                const v = grid[from.r][from.c];
                const fromCell = board.children[from.r * COLS + from.c];
                const fromTile = fromCell.querySelector('.tile');

                if (!fromTile || !path || path.length < 2) {
                    moveTileInstant(from, to);
                    if (callback) callback();
                    return;
                }

                // Ïù¥Îèô ÏãúÏûë Ï†ÑÏóê Î∞îÎã• ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî Ï∂îÍ∞Ä(ÍπúÎπ°ÏûÑ Î∞©ÏßÄ)
                addEmptyPlaceholderAt(from.r, from.c);

                const animatingTile = fromTile.cloneNode(true);
                animatingTile.classList.add('moving');
                highlightPath(path);

                // ÎÖºÎ¶¨ Ïù¥Îèô
                grid[from.r][from.c] = 0;
                grid[to.r][to.c] = v;

                fromTile.style.visibility = 'hidden';
                drawCell(from.r, from.c);

                board.appendChild(animatingTile);
                setTilePosition(animatingTile, path[0]);

                animateStepByStep(animatingTile, path, 0, () => {
                    animatingTile.remove();
                    removePlaceholderAt(from.r, from.c);

                    drawCell(to.r, to.c);
                    clearPathHighlight();

                    const finalTile = board.children[to.r * COLS + to.c].querySelector('.tile');
                    if (finalTile) { finalTile.classList.add('bump'); setTimeout(() => finalTile.classList.remove('bump'), 200); }
                    if (callback) callback();
                });
            }

            function setTilePosition(tile, gridPos) {
                const targetCell = board.children[gridPos.r * COLS + gridPos.c];
                const rect = targetCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();
                tile.style.position = 'absolute';
                tile.style.left = (rect.left - boardRect.left) + 'px';
                tile.style.top = (rect.top - boardRect.top) + 'px';
                tile.style.width = targetCell.offsetWidth + 'px';
                tile.style.height = targetCell.offsetHeight + 'px';
                tile.style.transition = 'none';
            }

            function animateStepByStep(tile, path, currentStep, callback) {
                if (currentStep >= path.length - 1) { if (callback) callback(); return; }
                const nextPos = path[currentStep + 1];
                const targetCell = board.children[nextPos.r * COLS + nextPos.c];
                const rect = targetCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();
                tile.style.transition = 'left 100ms ease-out, top 100ms ease-out';
                tile.style.left = (rect.left - boardRect.left) + 'px';
                tile.style.top = (rect.top - boardRect.top) + 'px';
                setTimeout(() => { animateStepByStep(tile, path, currentStep + 1, callback); }, 100);
            }

            function moveTileInstant(from, to) {
                const v = grid[from.r][from.c];
                addEmptyPlaceholderAt(from.r, from.c);
                grid[from.r][from.c] = 0; grid[to.r][to.c] = v;
                drawCell(from.r, from.c); removePlaceholderAt(from.r, from.c);
                drawCell(to.r, to.c);
                const tCell = board.children[to.r * COLS + to.c].querySelector('.tile');
                if (tCell) { tCell.classList.add('bump'); setTimeout(() => tCell.classList.remove('bump'), 200); }
            }

            /* ====== Í≤ΩÎ°ú ÌÉêÏÉâ ====== */
            function findPathViaEmpties(from, to) {
                const q = [from],
                    prev = Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
                    vis = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                vis[from.r][from.c] = true;
                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                while (q.length) {
                    const cur = q.shift();
                    for (const [dr, dc] of dirs) {
                        const nr = cur.r + dr, nc = cur.c + dc;
                        if (!inBounds(nr, nc) || vis[nr][nc]) continue;
                        if (nr === to.r && nc === to.c) { if (!isEmpty(nr, nc)) continue; }
                        else if (isBlocked(nr, nc) || isTile(nr, nc)) continue;
                        vis[nr][nc] = true; prev[nr][nc] = cur;
                        if (nr === to.r && nc === to.c) {
                            const path = []; let x = { r: nr, c: nc };
                            while (x) { path.push(x); x = prev[x.r][x.c]; }
                            path.reverse(); return path;
                        }
                        q.push({ r: nr, c: nc });
                    }
                }
                return null;
            }

            function destAdjacentSame(to, val) {
                return [[1, 0], [-1, 0], [0, 1], [0, -1]]
                    .some(([dr, dc]) => inBounds(to.r + dr, to.c + dc) && grid[to.r + dr][to.c + dc] === val);
            }

            function floodSame(sr, sc, val, g = grid) {
                const vis = Array.from({ length: ROWS }, () => Array(COLS).fill(false)), q = [{ r: sr, c: sc }], out = [];
                vis[sr][sc] = true;
                while (q.length) {
                    const { r, c } = q.shift(); out.push({ r, c });
                    for (const [dr, dc] of [[1, 0], [0, 1], [-1, 0], [0, -1]]) {
                        const nr = r + dr, nc = c + dc;
                        if (inBounds(nr, nc) && !vis[nr][nc] && g[nr][nc] === val) { vis[nr][nc] = true; q.push({ r: nr, c: nc }); }
                    }
                }
                return out;
            }

            function groupSizeIfMoved(from, to, val) {
                const tmp = cloneGrid(grid);
                tmp[from.r][from.c] = 0; tmp[to.r][to.c] = val;
                return floodSame(to.r, to.c, val, tmp).length;
            }

            /* ====== Î≥¥Îìú ÏÉùÏÑ± & ÏÉàÍ≤åÏûÑ ====== */
            function makeGrid() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }

            function newGame() {
                popupTitle.textContent = "Í≤åÏûÑ Ïò§Î≤Ñ";
                grid = makeGrid();

                const blockedCount = 3;
                placeRandomBlocks(-1, blockedCount);

                placeRandomTilesAvoidingTriples(INIT_TILES, 400);
                renderAll(true);
                // ÏãúÏûë ÏßÅÌõÑ ÏûêÎèô Î®∏ÏßÄ Í∏àÏßÄ(Ï¥àÍ∏∞ Î∞∞ÏπòÏóêÏÑú 3Í∞ú ÌöåÌîº Î°úÏßÅ ÏÇ¨Ïö©)
                turn = 0; untilSpawn = SPAWN_EVERY; spawnCount = 0; selected = null; gameOverShown = false;
                elTurn.textContent = '0'; elNext.textContent = String(SPAWN_EVERY);
                updateMegaLeft();
                popup.classList.remove('show');
                checkGameOverSoon();
            }

            /* ====== ÏÜåÌôò ====== */
            function placeRandomBlocks(v, count) {
                const E = listEmpty(); shuffle(E);
                for (let i = 0; i < count && i < E.length; i++) grid[E[i].r][E[i].c] = v;
            }
            function placeRandomTilesAvoidingTriples(count, maxTry = 200) {
                let placed = 0, tries = 0;
                while (placed < count && tries < maxTry) {
                    const E = listEmpty(); if (!E.length) break;
                    const p = E[(Math.random() * E.length) | 0], v = randomValue();
                    grid[p.r][p.c] = v;
                    if (findLowestGroupGE3()) { grid[p.r][p.c] = 0; } else { placed++; }
                    tries++;
                }
                if (placed < count) placeRandomTiles(count - placed);
            }
            function placeRandomTiles(count) {
                const E = listEmpty(); shuffle(E);
                for (let i = 0; i < count && i < E.length; i++) grid[E[i].r][E[i].c] = randomValue();
            }
            function spawnBatch() {
                spawnCount++;
                if (spawnCount % MEGA_INTERVAL === 0) {
                    info("üåü ÎåÄÏÜåÌôò! Î∏îÎ°ù 2Î∞∞ ÏÜåÌôò!");
                    for (let i = 0; i < SPAWN_BATCH * 2; i++) spawnOne();
                } else {
                    for (let i = 0; i < SPAWN_BATCH; i++) spawnOne();
                }
                updateMegaLeft();
            }
            function spawnOne() {
                const E = listEmpty(); if (!E.length) return false;
                const p = E[(Math.random() * E.length) | 0];
                grid[p.r][p.c] = randomValue();
                drawCell(p.r, p.c, { spawn: true }); // z-order ÏµúÏÉÅÎã®
                // ÏïàÏ†ÑÎπµ: spawn ÌÅ¥ÎûòÏä§ Î≥¥Ïû•
                const t = board.children[p.r * COLS + p.c].querySelector('.tile'); if (t) t.classList.add('spawn');
                return true;
            }
            /* ====== Î®∏ÏßÄ (ÎÇÆÏùÄ Ïà´Ïûê Ïö∞ÏÑ†, Í≤ΩÎ°ú Îî∞Îùº Î™®ÏÖò) ====== */

            // Í∑∏Î£π ÎÇ¥Î∂Ä 4Î∞©Ìñ• Í≤ΩÎ°ú (Í∞ôÏùÄ Í∞íÏùò Í∑∏Î£π Ïπ∏Îßå ÌÜµÍ≥º, ÎåÄÍ∞ÅÏÑ† Í∏àÏßÄ)
            function findPathWithinGroup(from, to, groupSet) {
                const q = [from], prev = new Map(), vis = new Set([key(from.r, from.c)]);
                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                while (q.length) {
                    const cur = q.shift();
                    if (cur.r === to.r && cur.c === to.c) {
                        const path = []; let k = key(cur.r, cur.c);
                        while (k) { const [rr, cc] = k.split(',').map(Number); path.push({ r: rr, c: cc }); k = prev.get(k); }
                        path.reverse(); return path;
                    }
                    for (const [dr, dc] of dirs) {
                        const nr = cur.r + dr, nc = cur.c + dc, nk = key(nr, nc);
                        if (!inBounds(nr, nc) || vis.has(nk)) continue;
                        if (!groupSet.has(nk)) continue;
                        vis.add(nk); prev.set(nk, key(cur.r, cur.c)); q.push({ r: nr, c: nc });
                    }
                }
                return null;
            }

            // Ìè¥Î∞±: Îß®Ìï¥Ìäº(ÏÑ∏Î°ú‚ÜíÍ∞ÄÎ°ú) ÏßÅÏÑ† Í≤ΩÎ°ú
            function manhattanFallbackPath(from, to) {
                const path = [{ r: from.r, c: from.c }];
                let r = from.r, c = from.c;
                while (r !== to.r) { r += (to.r > r ? 1 : -1); path.push({ r, c }); }
                while (c !== to.c) { c += (to.c > c ? 1 : -1); path.push({ r, c }); }
                return path;
            }

            // ÌòÑÏû¨ Î≥¥ÎìúÏóêÏÑú "Í∞ÄÏû• ÎÇÆÏùÄ Í∞í"Ïùò 3+ Í∑∏Î£π ÌïòÎÇò Ï∞æÍ∏∞
            function findLowestGroupGE3() {
                const seen = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                let best = null;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const v = grid[r][c];
                        if (v <= 0 || seen[r][c]) continue;
                        const comp = floodSame(r, c, v);
                        for (const p of comp) seen[p.r][p.c] = true;
                        if (comp.length >= 3) {
                            if (!best || v < best.val) best = { val: v, group: comp };
                        }
                    }
                }
                return best;
            }

            // Í∑∏Î£π Î®∏ÏßÄ Ïï†ÎãàÎ©îÏù¥ÏÖò(ÌîºÎ≤óÏúºÎ°ú Îëê Í∞úÍ∞Ä Í∏∏ Îî∞Îùº Ìù°Ïàò)
            function animateGroupMerge(group, pivot, val) {
                return new Promise((resolve) => {
                    // ÌîºÎ≤ó Ï†úÏô∏ 2Í∞ú ÏÑ†ÌÉù
                    const absorbers = group.filter(p => !(p.r === pivot.r && p.c === pivot.c)).slice(0, 2);
                    const gset = new Set(group.map(p => key(p.r, p.c)));

                    // Í∞Å Ìù°ÏàòÏûê Í≤ΩÎ°ú
                    const paths = absorbers.map(src => {
                        let path = findPathWithinGroup(src, pivot, gset);
                        if (!path || path.length < 2) path = manhattanFallbackPath(src, pivot);
                        return path;
                    });

                    // ÌÅ¥Î°† + ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî
                    const clones = absorbers.map((src, i) => {
                        const cell = board.children[src.r * COLS + src.c];
                        const tile = cell.querySelector('.tile');
                        addEmptyPlaceholderAt(src.r, src.c); // ÍπúÎπ°ÏûÑ Î∞©ÏßÄ
                        const clone = tile ? tile.cloneNode(true) : null;
                        if (tile) tile.style.visibility = 'hidden';
                        if (clone) {
                            clone.classList.add('moving');
                            board.appendChild(clone);
                            setTilePosition(clone, paths[i][0]);
                        }
                        return { src, clone };
                    });

                    // Í≤ΩÎ°ú ÌïòÏù¥ÎùºÏù¥Ìä∏
                    paths.forEach(p => highlightPath(p));

                    let finished = 0;
                    const onOneDone = () => { finished++; if (finished === paths.length) afterAllArrived(); };

                    clones.forEach((pack, i) => {
                        const cl = pack.clone;
                        if (!cl) { onOneDone(); return; }
                        animateStepByStep(cl, paths[i], 0, () => { onOneDone(); });
                    });

                    function afterAllArrived() {
                        // ÌÅ¥Î°† Ï†úÍ±∞ + placeholder Ï†úÍ±∞
                        clones.forEach(p => { if (p.clone) p.clone.remove(); });
                        absorbers.forEach(p => removePlaceholderAt(p.r, p.c));

                        // Ïã§Ï†ú Î®∏ÏßÄ Ï†ÅÏö©
                        for (const p of absorbers) { grid[p.r][p.c] = 0; drawCell(p.r, p.c); }
                        grid[pivot.r][pivot.c] = val * 3; drawCell(pivot.r, pivot.c);

                        clearPathHighlight();

                        const tCell = board.children[pivot.r * COLS + pivot.c].querySelector('.tile');
                        if (tCell) { tCell.classList.add('merge'); setTimeout(() => tCell.classList.remove('merge'), 240); }
                        try {
                            if (sounds.blocks[val * 3]) { sounds.blocks[val * 3].currentTime = 0; sounds.blocks[val * 3].play().catch(() => { }); }
                        } catch (e) { }

                        resolve();
                    }
                });
            }

            // Ïó∞ÏáÑ Î®∏ÏßÄ: "Ìï≠ÏÉÅ ÎÇÆÏùÄ Ïà´ÏûêÎ∂ÄÌÑ∞" Ìïú Î≤àÏóê ÌïòÎÇòÏî© Ï≤òÎ¶¨
            async function resolveAutoMergesAsync(forcePivot = null) {
                while (true) {
                    let pick;
                    if (forcePivot) {
                        // Í∞ïÏ†ú ÌîºÎ≤óÏù¥ ÏÜçÌïú Í∑∏Î£πÏùÑ Ïö∞ÏÑ†(ÎÇÆÏùÄ Ïà´Ïûê ÏòàÏô∏ ÏóÜÏù¥, Ï≤´ Ïä§ÌÖùÎßå)
                        const val = grid[forcePivot.r][forcePivot.c];
                        if (val > 0) {
                            const group = floodSame(forcePivot.r, forcePivot.c, val);
                            if (group.length >= 3) {
                                await animateGroupMerge(group, forcePivot, val);
                                saveSnapshot();
                                forcePivot = null;
                                continue; // Îã§Ïãú Ïä§Ï∫î
                            }
                        }
                        forcePivot = null;
                    }
                    pick = findLowestGroupGE3();
                    if (!pick) break;
                    const { val, group } = pick;
                    const pivot = group[0]; // Í∑∏Î£π ÎÇ¥ ÏûÑÏùò(ÏùºÍ¥ÄÏÑ± ÏúÑÌï¥ Ï≤´ ÏöîÏÜå)
                    await animateGroupMerge(group, pivot, val);
                    saveSnapshot();
                }
            }

            // Ìïú ÌÑ¥ ÌååÏù¥ÌîÑÎùºÏù∏: (1) Î®∏ÏßÄ ‚Üí (2) ÌïÑÏöî Ïãú Ïä§Ìè∞ ‚Üí (3) Îã§Ïãú Î®∏ÏßÄ
            async function completeTurnPipeline(pivotOrNull) {
                await resolveAutoMergesAsync(pivotOrNull);

                // ÌÑ¥/Ïä§Ìè∞ Ï≤òÎ¶¨
                turn++; untilSpawn--;
                if (untilSpawn === 0) {
                    spawnBatch();          // Ïä§Ìè∞ Î®ºÏ†Ä
                    await resolveAutoMergesAsync(null); // Ïä§Ìè∞ÏúºÎ°ú ÏÉùÍ∏¥ Ïã†Í∑ú Î®∏ÏßÄÎèÑ ÏàòÌñâ
                    untilSpawn = SPAWN_EVERY;
                }

                // UI, ÏÑ†ÌÉù Ï¥àÍ∏∞Ìôî
                updateMegaLeft();
                saveSnapshot();
                elTurn.textContent = String(turn);
                elNext.textContent = String(untilSpawn);
                selected = null; highlightSelection(); clearPossibleMoves();

                isAnimating = false; // Ï†ÑÏ≤¥ ÌååÏù¥ÌîÑÎùºÏù∏ Ìï¥Ï†ú
                checkGameOverSoon();
            }
            /* ====== Í≤åÏûÑÏò§Î≤Ñ ====== */
            function legalMoveExistsForTile(r, c) {
                const v = grid[r][c]; const currentGroup = floodSame(r, c, v);
                for (let rr = 0; rr < ROWS; rr++) for (let cc = 0; cc < COLS; cc++) {
                    if (!isEmpty(rr, cc)) continue;
                    const to = { r: rr, c: cc }; const path = findPathViaEmpties({ r, c }, to); if (!path) continue;
                    if (!destAdjacentSame(to, v)) continue;
                    const gsize = groupSizeIfMoved({ r, c }, to, v); if (gsize < 2) continue;
                    if (currentGroup.length === 2 && gsize < 3) continue;
                    return true;
                }
                return false;
            }
            function hasAnyMoves() {
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (grid[r][c] > 0 && legalMoveExistsForTile(r, c)) return true;
                return false;
            }
            function checkGameOverSoon() {
                setTimeout(() => {
                    if (!gameOverShown && !hasAnyMoves()) {
                        gameOverShown = true;
                        const total = grid.flat().filter(v => v > 0).reduce((a, b) => a + b, 0);
                        showResult(total);
                    }
                }, 30);
            }

            /* ====== ÌûàÏä§ÌÜ†Î¶¨ ====== */
            function saveSnapshot() {
                history.push({ grid: cloneGrid(grid), turn, untilSpawn });
                if (history.length > 50) history.shift();
            }

            /* ====== Í≤∞Í≥º/Îû≠ÌÇπ ====== */
            async function showResult(total) {
                popupTitle.textContent = "Í≤åÏûÑ Ïò§Î≤Ñ";
                finalScore.textContent = `${playerId}Ïùò ÏµúÏ¢Ö Ï†êÏàò: ${total}`;
                noMovesMsg.style.display = "block";
                lastGameState = cloneGrid(grid);

                if (total > bestScore) {
                    bestScore = total; bestGameState = cloneGrid(grid);
                    localStorage.setItem("mergeBestScore", bestScore);
                    localStorage.setItem("mergeBestState", JSON.stringify(bestGameState));
                }

                rankingsEl.innerHTML = "<div style='padding:10px'>Îû≠ÌÇπÏùÑ Î∂àÎü¨Ïò§ÎäîÏ§ë...</div>";
                popup.classList.add('show');

                try { sounds.gameover.currentTime = 0; sounds.gameover.play().catch(() => { }); } catch (e) { }

                try {
                    await fetch(GAS_URL, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ secret: "TEST2", name: playerId, score: total, state: grid }),
                        mode: "no-cors"
                    });
                } catch (e) { console.error("‚ùå POST Ïò§Î•ò:", e); }

                loadRanking();
            }

            async function loadRanking() {
                try {
                    const res = await fetch(`${GAS_URL}?mode=ranking`, { cache: "no-cache" });
                    let data = []; try { data = await res.json(); } catch (e) { console.error("‚ùå JSON ÌååÏã± Ïã§Ìå®:", e); }
                    renderRanking(Array.isArray(data) ? data.slice(0, 100) : []);
                } catch (e) {
                    console.error("‚ùå Îû≠ÌÇπ fetch Ïã§Ìå®:", e);
                    renderRanking([]);
                }
            }

            function renderRanking(rows) {
                rankingsEl.innerHTML = "";
                if (!rows || rows.length === 0) {
                    const empty = document.createElement('div'); empty.style.padding = '10px'; empty.textContent = 'Îû≠ÌÇπ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.'; rankingsEl.appendChild(empty); return;
                }
                rows.forEach((row, i) => {
                    const item = document.createElement('div');
                    item.className = 'rank-item' + (i === 0 ? ' top1' : i === 1 ? ' top2' : i === 2 ? ' top3' : '');
                    const left = document.createElement('div'); left.className = 'left';
                    const crown = document.createElement('span'); crown.className = 'crown'; crown.textContent = (i < 3 ? 'üëë' : ''); left.appendChild(crown);
                    const name = document.createElement('span'); name.textContent = `${i + 1}. ${row.name}`; left.appendChild(name);

                    const right = document.createElement('div'); right.className = 'right';
                    if (i < 3) {
                        const btn = document.createElement('button'); btn.textContent = "Î≥¥Í∏∞"; btn.className = "btn";
                        btn.addEventListener('click', async () => {
                            try {
                                if (row.state) { renderMiniPopup(JSON.parse(row.state), row.name, row.score); }
                                else {
                                    const res = await fetch(`${GAS_URL}?mode=last&name=${encodeURIComponent(row.name)}`);
                                    const data = await res.json();
                                    if (data.state) renderMiniPopup(JSON.parse(data.state), data.name, data.score);
                                    else alert("Ï†ÄÏû•Îêú Ï†ÑÏ†ÅÏù¥ ÏóÜÏäµÎãàÎã§.");
                                }
                            } catch (e) { console.error("‚ùå last fetch Ïò§Î•ò:", e); alert("Ï†ÑÏ†ÅÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§."); }
                        });
                        right.appendChild(btn);
                    }
                    const score = document.createElement('span'); score.className = 'score'; score.textContent = `${row.score}`;
                    right.appendChild(score);

                    item.appendChild(left); item.appendChild(right); rankingsEl.appendChild(item);
                });
            }

            /* ====== ÎØ∏ÎãàÌåùÏóÖ ====== */
            function renderMiniPopup(state, id, score) {
                let mini = document.getElementById('miniPopup');
                if (!mini) {
                    mini = document.createElement('div'); mini.id = 'miniPopup';
                    mini.style.position = 'fixed'; mini.style.inset = '0'; mini.style.background = 'rgba(0,0,0,0.6)';
                    mini.style.display = 'flex'; mini.style.alignItems = 'center'; mini.style.justifyContent = 'center';
                    mini.style.zIndex = '2000'; document.body.appendChild(mini);
                }
                mini.innerHTML = '';
                const box = document.createElement('div');
                box.style.background = '#161c29'; box.style.padding = '16px'; box.style.borderRadius = '12px';
                box.style.textAlign = 'center'; box.style.boxShadow = '0 6px 20px rgba(0,0,0,0.6)';
                const title = document.createElement('h3'); title.textContent = `${id} ÏµúÏ¢Ö Î≥¥Îìú (Ï†êÏàò ${score})`; box.appendChild(title);

                const wrap = document.createElement('div');
                wrap.style.display = 'grid';
                wrap.style.gridTemplateColumns = `repeat(${COLS},1fr)`;
                wrap.style.gridTemplateRows = `repeat(${ROWS},1fr)`;
                wrap.style.gap = '4px'; wrap.style.width = '90%'; wrap.style.maxWidth = '420px';
                wrap.style.aspectRatio = `${COLS}/${ROWS}`; wrap.style.margin = '12px auto';
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = '100%'; cell.style.aspectRatio = '1/1'; cell.style.border = '1px solid #222'; cell.style.background = '#111';
                    const v = state[r][c];
                    if (v > 0 && TILE_IMAGES[v]) { cell.style.backgroundImage = `url(${TILE_IMAGES[v]})`; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    else if (v === -1) { cell.style.backgroundImage = "url('images/blocked.png')"; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    else { cell.style.backgroundImage = "url('images/empty.png')"; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    wrap.appendChild(cell);
                }
                box.appendChild(wrap);
                const close = document.createElement('button'); close.textContent = 'Îã´Í∏∞'; close.className = 'btn'; close.style.marginTop = '10px'; close.onclick = () => mini.remove(); box.appendChild(close);
                mini.appendChild(box);
            }

            /* ====== Í∏∞ÌÉÄ Ïù¥Î≤§Ìä∏ ====== */
            document.addEventListener('click', (e) => {
                if (!toast.classList.contains('show')) return;
                if (e.target.closest('#toast')) return;
                if (toastTimer) clearTimeout(toastTimer);
                setTimeout(() => { toast.classList.remove('show'); toastTimer = null; }, 50);
            }, true);

            /* ====== ÏãúÏûë ====== */
            preloadImages(IMAGE_URLS).then(() => { init(); });

        })(); // IIFE ÎÅù

        // üéµ Ï≤´ ÌÑ∞Ïπò/ÌÅ¥Î¶≠ Ïãú BGM ÏãúÏûë + ÏãúÏûë Î©îÏãúÏßÄ Ïà®ÍπÄ
        function startBgm() {
            if (sounds.bgm && sounds.bgm.paused) {
                sounds.bgm.play().then(() => { console.log("üé∂ BGM ÏãúÏûëÎê®"); }).catch(err => { console.log("üîá BGM ÏãúÏûë Ïã§Ìå®:", err); });
            }
        }
        function hideStartMsg() { const m = document.getElementById("startMsg"); if (m) m.classList.add("hide"); }
        document.addEventListener("touchstart", () => { startBgm(); hideStartMsg(); }, { once: true });
        document.addEventListener("click", () => { startBgm(); hideStartMsg(); }, { once: true });

        // Ïï±/ÌÉ≠ Ï†ÑÌôò Ïãú BGM Ï†úÏñ¥
        function pauseBgm() { if (window.sounds && window.sounds.bgm && !window.sounds.bgm.paused) { sounds.bgm.pause(); } }
        function resumeBgm() { if (window.sounds && window.sounds.bgm) { sounds.bgm.play().catch(err => console.log("Ïû¨ÏÉù Ïã§Ìå®:", err)); } }
        document.addEventListener("visibilitychange", () => { if (document.hidden) pauseBgm(); else resumeBgm(); });
        window.addEventListener("pagehide", pauseBgm);
        window.addEventListener("pageshow", resumeBgm);
        window.addEventListener("blur", pauseBgm);
        window.addEventListener("focus", resumeBgm);
    </script>
</body>
</html>
